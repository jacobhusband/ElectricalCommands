# Bundled project files → prompt.txt
# Generated: 2025-09-23T18:37:14
# Directory: C:\Users\JacobH\Dotnet\Finalize\AutoCADCommands\CleanCADCommands

## File list (in order):
- CleanCadCommand.cs
- CleanupCommands.cs
- DetachSpecialXrefsCommand.cs
- DetectPaperSpaceXrefsCommand.cs
- EmbedFromXrefsCommand.cs
- EraseOtherCommand.cs
- FinalizeCleanupCommand.cs
- FinalizeDrawingCommand.cs
- FinalizePurgeDefsCommand.cs
- FindTitleBlockCommand.cs
- KeepOnlyTitleBlockCommand.cs
- SimplerCommands.cs
- ViewportToPolyline.cs

Request:
Can we update "EMBEDFROMXREFS" command method, after embedding all the iamges, autocad can freeze on the last image. It also typically ends the command with a pasteclip command.

===== BEGIN CleanCadCommand.cs =====
```csharp
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.DatabaseServices;

namespace AutoCADCleanupTool
{
    public partial class SimplerCommands
    {
        private enum CleanWorkflowKind
        {
            TitleBlock,
            Sheet
        }

        [CommandMethod("CLEANTBLK", CommandFlags.Modal)]
        public static void RunCleanTitleBlock()
        {
            // Leave the title-block workflow as-is.
            RunCleanWorkflow(CleanWorkflowKind.TitleBlock);
        }

        [CommandMethod("CLEANSHEET", CommandFlags.Modal)]
        public static void RunCleanSheet()
        {
            var doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            var ed = doc.Editor;
            var db = doc.Database;


            try
            {
                if (TryGetTitleBlockOutlinePointsForEmbed(db, out var tbPoly) && tbPoly != null && tbPoly.Length > 0)
                {
                    ed.WriteMessage("\nTitle block found, zooming in...");
                    ZoomToTitleBlockForEmbed(ed, tbPoly);
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\n[Warning] Could not zoom to title block: {ex.Message}");
            }

            try
            {
                // Set necessary flags for the entire workflow before starting.
                CleanupCommands.SkipBindDuringFinalize = false;
                CleanupCommands.ForceDetachOriginalXrefs = false;
                CleanupCommands.RunKeepOnlyAfterFinalize = false;
                _chainFinalizeAfterEmbed = false; // Ensure EMBEDFROMXREFS doesn't chain a command on its own.

                ed.WriteMessage("\nCLEANSHEET: Queuing EMBEDFROMXREFS → CLEANPS → VP2PL → FINALIZE ...");

                // Queue the entire sequence of commands in a single string.
                // AutoCAD will execute them one by one after the current command scope ends.
                // The space at the end ensures the last command is executed.
                doc.SendStringToExecute("_.EMBEDFROMXREFS _.CLEANPS _.VP2PL _.FINALIZE ", true, false, false);
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nCLEANSHEET failed to queue commands: {ex.Message}");
            }
        }

        // Legacy alias should map to the new CLEANSHEET behavior (not the shared workflow).
        [CommandMethod("CLEANCAD", CommandFlags.Modal)]
        public static void RunCleanCad()
        {
            RunCleanSheet();
        }

        // Existing shared workflow remains for CLEANTBLK only.
        private static void RunCleanWorkflow(CleanWorkflowKind kind)
        {
            var doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            var db = doc.Database;
            var ed = doc.Editor;

            try
            {
                PrepareXrefLayersForCleanup(db, ed);

                CleanupCommands.SkipBindDuringFinalize = kind == CleanWorkflowKind.TitleBlock;
                CleanupCommands.ForceDetachOriginalXrefs = kind == CleanWorkflowKind.TitleBlock;
                CleanupCommands.RunKeepOnlyAfterFinalize = kind == CleanWorkflowKind.Sheet;

                if (kind == CleanWorkflowKind.TitleBlock)
                {
                    CleanupCommands.KeepOnlyTitleBlockInModelSpace();
                    DetachSpecialXrefs();
                    _chainFinalizeAfterEmbed = true;
                    EmbedFromXrefs();
                }
                else
                {
                    // No longer used by CLEANSHEET — left intact for compatibility.
                    CleanupCommands.ListPaperSpaceXrefs();
                    CleanupCommands.ViewportToPolyline_AllLayouts();
                    DetachSpecialXrefs();
                    _chainFinalizeAfterEmbed = true;
                    EmbedFromXrefs();
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nClean workflow failed: {ex.Message}");
                _chainFinalizeAfterEmbed = false;
                CleanupCommands.RunKeepOnlyAfterFinalize = false;
                CleanupCommands.SkipBindDuringFinalize = false;
                CleanupCommands.ForceDetachOriginalXrefs = false;
            }
        }

        private static void PrepareXrefLayersForCleanup(Database db, Editor ed)
        {
            try
            {
                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var lt = (LayerTable)tr.GetObject(db.LayerTableId, OpenMode.ForRead);
                    if (!lt.Has("0"))
                    {
                        ed.WriteMessage("\nLayer '0' was not found; skipping XREF layer normalization.");
                        tr.Commit();
                        return;
                    }

                    var zeroId = lt["0"];
                    var zeroLayer = (LayerTableRecord)tr.GetObject(zeroId, OpenMode.ForWrite);
                    bool zeroWasLocked = zeroLayer.IsLocked;
                    if (zeroLayer.IsFrozen) zeroLayer.IsFrozen = false;
                    if (zeroLayer.IsOff) zeroLayer.IsOff = false;
                    if (zeroWasLocked) zeroLayer.IsLocked = false;

                    try
                    {
                        var bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead);
                        int moved = 0;
                        foreach (ObjectId recordId in bt)
                        {
                            var space = (BlockTableRecord)tr.GetObject(recordId, OpenMode.ForRead);
                            foreach (ObjectId entId in space)
                            {
                                var br = tr.GetObject(entId, OpenMode.ForRead) as BlockReference;
                                if (br == null) continue;

                                BlockTableRecord def = null;
                                try { def = tr.GetObject(br.BlockTableRecord, OpenMode.ForRead) as BlockTableRecord; }
                                catch { }

                                if (def == null || !def.IsFromExternalReference) continue;
                                if (br.LayerId == zeroId) continue;

                                LayerTableRecord sourceLayer = null;
                                bool relockSource = false;
                                try { sourceLayer = (LayerTableRecord)tr.GetObject(br.LayerId, OpenMode.ForRead); }
                                catch { }

                                if (sourceLayer != null && sourceLayer.IsLocked)
                                {
                                    sourceLayer.UpgradeOpen();
                                    sourceLayer.IsLocked = false;
                                    relockSource = true;
                                }

                                br.UpgradeOpen();
                                br.LayerId = zeroId;
                                moved++;

                                if (relockSource && sourceLayer != null)
                                {
                                    sourceLayer.IsLocked = true;
                                }
                            }
                        }

                        if (moved > 0)
                        {
                            ed.WriteMessage($"\nMoved {moved} XREF block reference(s) to layer '0'.");
                        }

                        if (zeroWasLocked)
                        {
                            zeroLayer.IsLocked = true;
                        }

                        tr.Commit();
                    }
                    finally
                    {
                        if (zeroWasLocked && !zeroLayer.IsLocked)
                        {
                            try { zeroLayer.IsLocked = true; } catch { }
                        }
                    }
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nFailed to normalize XREF layers: {ex.Message}");
            }
        }
    }
}
```
===== END CleanCadCommand.cs =====

===== BEGIN CleanupCommands.cs =====
```csharp
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AutoCADCleanupTool
{
    public partial class CleanupCommands
    {
        // Static variables to pass state between commands
        private static HashSet<ObjectId> _blockIdsBeforeBind = new HashSet<ObjectId>();
        private static HashSet<ObjectId> _originalXrefIds = new HashSet<ObjectId>();
        private static HashSet<ObjectId> _imageDefsToPurge = new HashSet<ObjectId>(); // Our definitive "kill list"
        internal static bool RunKeepOnlyAfterFinalize = false;
        internal static bool SkipBindDuringFinalize = false;
        internal static bool ForceDetachOriginalXrefs = false;


        private static Extents3d? TryGetExtents(Entity ent)
        {
            try { return ent.GeometricExtents; }
            catch { try { return ent.Bounds; } catch { return (Extents3d?)null; } }
        }

        private static bool PointInExtents2D(Point3d p, Extents3d e)
        {
            return p.X >= e.MinPoint.X - 1e-9 && p.X <= e.MaxPoint.X + 1e-9 &&
                   p.Y >= e.MinPoint.Y - 1e-9 && p.Y <= e.MaxPoint.Y + 1e-9;
        }

        private static bool IsSheetRatio(double r)
        {
            if (r <= 0) return false;
            double[] target = { 1.4142, 1.5, 1.3333, 1.2941, 1.5455 }; // ISO A, Arch D, Arch E, ANSI A/C/E, ANSI B/D
            return target.Any(t => Math.Abs(r - t) <= 0.12);
        }

        private static (bool ok, double w, double h, double angle) TryRectInfo(Polyline pl)
        {
            if (pl.NumberOfVertices != 4 || !pl.Closed) return (false, 0, 0, 0);
            var p0 = pl.GetPoint2dAt(0); var p1 = pl.GetPoint2dAt(1); var p2 = pl.GetPoint2dAt(2); var p3 = pl.GetPoint2dAt(3);
            var v0 = p1 - p0; var v1 = p2 - p1; var v2 = p3 - p2; var v3 = p0 - p3;
            double w = v0.Length; double h = v1.Length;
            if (w <= 1e-9 || h <= 1e-9) return (false, 0, 0, 0);
            bool ortho = Math.Abs(v0.X * v1.X + v0.Y * v1.Y) <= 1e-3 * w * h &&
                         Math.Abs(v1.X * v2.X + v1.Y * v2.Y) <= 1e-3 * w * h &&
                         Math.Abs(v2.X * v3.X + v2.Y * v3.Y) <= 1e-3 * w * h;
            if (!ortho) return (false, 0, 0, 0);
            var longEdge = w >= h ? v0 : v1;
            double angle = Math.Atan2(longEdge.Y, longEdge.X);
            return (true, w, h, angle);
        }

        internal static int EraseEntitiesExcept(Database db, Editor ed, ObjectId spaceId, HashSet<ObjectId> idsToKeep)
        {
            int erasedCount = 0;
            try
            {
                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var space = (BlockTableRecord)tr.GetObject(spaceId, OpenMode.ForRead);
                    var layersToUnlock = new HashSet<ObjectId>();
                    var idsToErase = new List<ObjectId>();

                    foreach (ObjectId id in space)
                    {
                        if (idsToKeep != null && idsToKeep.Contains(id))
                        {
                            continue;
                        }

                        var ent = tr.GetObject(id, OpenMode.ForRead) as Entity;
                        if (ent == null) continue;
                        idsToErase.Add(id);
                        var layer = tr.GetObject(ent.LayerId, OpenMode.ForRead) as LayerTableRecord;
                        if (layer != null && layer.IsLocked)
                        {
                            layersToUnlock.Add(ent.LayerId);
                        }
                    }

                    foreach (var layerId in layersToUnlock)
                    {
                        var layer = (LayerTableRecord)tr.GetObject(layerId, OpenMode.ForWrite);
                        layer.IsLocked = false;
                    }

                    foreach (var id in idsToErase)
                    {
                        var ent = tr.GetObject(id, OpenMode.ForWrite) as Entity;
                        if (ent == null) continue;
                        ent.Erase();
                        erasedCount++;
                    }

                    foreach (var layerId in layersToUnlock)
                    {
                        var layer = (LayerTableRecord)tr.GetObject(layerId, OpenMode.ForWrite);
                        layer.IsLocked = true;
                    }

                    tr.Commit();
                }

                if (erasedCount > 0)
                {
                    ed.WriteMessage($"\nErased {erasedCount} object(s).");
                    ed.Regen();
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nFailed to erase entities: {ex.Message}");
            }

            return erasedCount;
        }
        private static bool ExtentsIntersectXY(Extents3d a, Extents3d b)
        {
            return a.MinPoint.X <= b.MaxPoint.X && a.MaxPoint.X >= b.MinPoint.X &&
                   a.MinPoint.Y <= b.MaxPoint.Y && a.MaxPoint.Y >= b.MinPoint.Y;
        }

        private static bool ExtentsContainsXY(Extents3d container, Extents3d item)
        {
            return container.MinPoint.X <= item.MinPoint.X &&
                   container.MinPoint.Y <= item.MinPoint.Y &&
                   container.MaxPoint.X >= item.MaxPoint.X &&
                   container.MaxPoint.Y >= item.MaxPoint.Y;
        }

    }
}
```
===== END CleanupCommands.cs =====

===== BEGIN DetachSpecialXrefsCommand.cs =====
```csharp
﻿using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using System;
using System.Collections.Generic;

namespace AutoCADCleanupTool
{
    public partial class SimplerCommands
    {
        [CommandMethod("DETACHSPECIALXREFS", CommandFlags.Modal)]
        public static void DetachSpecialXrefs()
        {
            var doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            var db = doc.Database;
            var ed = doc.Editor;

            // Case-insensitive tokens
            var imageTokens = new[] { "wl-sig", "christian" };
            var dwgTokens = new[] { "acieslogo", "cdstamp" };

            int dwgDetached = 0;
            int imagesErased = 0;
            int imageDefsDetached = 0;
            int blockRefsErased = 0;
            int blockDefsErased = 0;
            int layersFrozen = 0;

            try
            {
                // 1) Detach DWG XREFs that match tokens or contain both "WL" and "sig"
                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead);
                    var toDetach = new List<ObjectId>();

                    foreach (ObjectId btrId in bt)
                    {
                        var btr = (BlockTableRecord)tr.GetObject(btrId, OpenMode.ForRead);
                        if (btr == null || !btr.IsFromExternalReference) continue;

                        string name = (btr.Name ?? string.Empty).ToLowerInvariant();
                        string path = (btr.PathName ?? string.Empty);
                        string fileNoExt = string.Empty;
                        try { fileNoExt = System.IO.Path.GetFileNameWithoutExtension(path)?.ToLowerInvariant() ?? string.Empty; } catch { }

                        bool match = false;
                        foreach (var t in dwgTokens)
                        {
                            var token = t.ToLowerInvariant();
                            if (name.Contains(token) || (!string.IsNullOrEmpty(fileNoExt) && fileNoExt.Contains(token)))
                            {
                                match = true;
                                break;
                            }
                        }

                        // Also match if BOTH substrings "wl" and "sig" are present (case-insensitive)
                        if (!match)
                        {
                            bool nameWlSig = name.Contains("wl") && name.Contains("sig");
                            bool fileWlSig = !string.IsNullOrEmpty(fileNoExt) && fileNoExt.Contains("wl") && fileNoExt.Contains("sig");
                            if (nameWlSig || fileWlSig)
                                match = true;
                        }

                        if (match)
                        {
                            toDetach.Add(btrId);
                        }
                    }

                    foreach (var xrefId in toDetach)
                    {
                        try { db.DetachXref(xrefId); dwgDetached++; }
                        catch (System.Exception ex) { ed.WriteMessage($"\nFailed to detach DWG XREF {xrefId}: {ex.Message}"); }
                    }

                    tr.Commit();
                }

                // 2) Detach image references/defs that match tokens
                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var nod = (DBDictionary)tr.GetObject(db.NamedObjectsDictionaryId, OpenMode.ForRead);
                    if (!nod.Contains("ACAD_IMAGE_DICT"))
                    {
                        tr.Commit();
                    }
                    else
                    {
                        var imageDict = (DBDictionary)tr.GetObject(nod.GetAt("ACAD_IMAGE_DICT"), OpenMode.ForWrite);

                        // Gather candidate defs by key or source file name
                        var candidates = new List<(string Key, ObjectId DefId)>();
                        foreach (DBDictionaryEntry entry in imageDict)
                        {
                            string key = entry.Key ?? string.Empty;
                            var def = tr.GetObject(entry.Value, OpenMode.ForRead) as RasterImageDef;
                            string src = def?.SourceFileName ?? string.Empty;
                            string keyLower = key.ToLowerInvariant();
                            string nameLower = string.Empty;
                            string nameNoExtLower = string.Empty;
                            try { nameLower = System.IO.Path.GetFileName(src)?.ToLowerInvariant() ?? string.Empty; } catch { }
                            try { nameNoExtLower = System.IO.Path.GetFileNameWithoutExtension(src)?.ToLowerInvariant() ?? string.Empty; } catch { }

                            bool match = false;
                            foreach (var t in imageTokens)
                            {
                                var token = t.ToLowerInvariant();
                                if (keyLower.Contains(token) || nameLower.Contains(token) || nameNoExtLower.Contains(token))
                                {
                                    match = true;
                                    break;
                                }
                            }
                            // Also match if BOTH substrings "wl" and "sig" are present (case-insensitive)
                            if (!match)
                            {
                                bool keyWlSig = keyLower.Contains("wl") && keyLower.Contains("sig");
                                bool nameWlSig = nameLower.Contains("wl") && nameLower.Contains("sig");
                                bool nameNoExtWlSig = nameNoExtLower.Contains("wl") && nameNoExtLower.Contains("sig");
                                if (keyWlSig || nameWlSig || nameNoExtWlSig)
                                {
                                    match = true;
                                }
                            }
                            if (match)
                            {
                                candidates.Add((key, entry.Value));
                            }
                        }

                        if (candidates.Count > 0)
                        {
                            // Build an index of raster images by def id
                            var bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead);
                            var imagesByDef = new Dictionary<ObjectId, List<ObjectId>>();
                            foreach (var c in candidates)
                                imagesByDef[c.DefId] = new List<ObjectId>();

                            foreach (ObjectId btrId in bt)
                            {
                                var btr = (BlockTableRecord)tr.GetObject(btrId, OpenMode.ForRead);
                                foreach (ObjectId entId in btr)
                                {
                                    if (entId.ObjectClass.DxfName != "IMAGE") continue;
                                    var img = tr.GetObject(entId, OpenMode.ForRead) as RasterImage;
                                    if (img == null || img.ImageDefId.IsNull) continue;
                                    if (imagesByDef.ContainsKey(img.ImageDefId))
                                    {
                                        imagesByDef[img.ImageDefId].Add(entId);
                                    }
                                }
                            }

                            // Erase image references and then remove defs
                            foreach (var c in candidates)
                            {
                                // Erase all image entities referencing this def
                                if (imagesByDef.TryGetValue(c.DefId, out var entIds))
                                {
                                    foreach (var entId in entIds)
                                    {
                                        try
                                        {
                                            var img = tr.GetObject(entId, OpenMode.ForWrite, false) as RasterImage;
                                            if (img != null)
                                            {
                                                // Unlock layer if needed
                                                var layer = (LayerTableRecord)tr.GetObject(img.LayerId, OpenMode.ForRead);
                                                bool relock = false;
                                                if (layer.IsLocked)
                                                {
                                                    layer.UpgradeOpen();
                                                    layer.IsLocked = false;
                                                    relock = true;
                                                }
                                                img.Erase();
                                                imagesErased++;
                                                if (relock) layer.IsLocked = true;
                                            }
                                        }
                                        catch (System.Exception ex)
                                        {
                                            ed.WriteMessage($"\nFailed erasing image ref {entId}: {ex.Message}");
                                        }
                                    }
                                }

                                // Remove dictionary key and erase def
                                try { imageDict.Remove(c.Key); } catch { }
                                try
                                {
                                    var def = tr.GetObject(c.DefId, OpenMode.ForWrite, false);
                                    def?.Erase();
                                    imageDefsDetached++;
                                }
                                catch (System.Exception ex)
                                {
                                    ed.WriteMessage($"\nFailed to detach image def '{c.Key}': {ex.Message}");
                                }
                            }
                        }

                        tr.Commit();
                    }
                }

                // 3) Delete block references and block definitions matching patterns
                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead);

                    // Identify matching block definitions (non-layout, non-xref)
                    var matchedDefs = new HashSet<ObjectId>();
                    foreach (ObjectId btrId in bt)
                    {
                        var btr = (BlockTableRecord)tr.GetObject(btrId, OpenMode.ForRead);
                        if (btr == null) continue;
                        if (btr.IsLayout || btr.IsDependent || btr.IsFromExternalReference) continue;

                        // Case-insensitive match for specific block name tokens
                        string bname = (btr.Name ?? string.Empty).ToLowerInvariant();
                        bool match =
                            bname.Contains("acieslogo") ||
                            bname.Contains("wlstamp") ||
                            bname.Contains("christian") ||
                            (bname.Contains("wl") && bname.Contains("sig")); // keep old heuristic
                        if (match) matchedDefs.Add(btrId);
                    }

                    if (matchedDefs.Count > 0)
                    {
                        // Collect all block references to these definitions (including dynamic base)
                        var refsToErase = new List<ObjectId>();
                        foreach (ObjectId spaceId in bt)
                        {
                            var btr = (BlockTableRecord)tr.GetObject(spaceId, OpenMode.ForRead);
                            foreach (ObjectId entId in btr)
                            {
                                if (entId.ObjectClass.DxfName != "INSERT") continue;
                                var br = tr.GetObject(entId, OpenMode.ForRead) as BlockReference;
                                if (br == null) continue;

                                bool refMatch = matchedDefs.Contains(br.BlockTableRecord);
                                if (!refMatch && br.IsDynamicBlock)
                                {
                                    try { refMatch = matchedDefs.Contains(br.DynamicBlockTableRecord); } catch { }
                                }
                                if (refMatch)
                                {
                                    refsToErase.Add(entId);
                                }
                            }
                        }

                        // Erase all matching references (unlock layer temporarily if needed)
                        foreach (var entId in refsToErase)
                        {
                            try
                            {
                                var br = tr.GetObject(entId, OpenMode.ForWrite, false) as BlockReference;
                                if (br != null)
                                {
                                    var layer = (LayerTableRecord)tr.GetObject(br.LayerId, OpenMode.ForRead);
                                    bool relock = false;
                                    if (layer.IsLocked)
                                    {
                                        layer.UpgradeOpen();
                                        layer.IsLocked = false;
                                        relock = true;
                                    }
                                    br.Erase();
                                    blockRefsErased++;
                                    if (relock) layer.IsLocked = true;
                                }
                            }
                            catch (System.Exception ex)
                            {
                                ed.WriteMessage($"\nFailed erasing block reference {entId}: {ex.Message}");
                            }
                        }

                        // Try to erase the block definitions now that refs are gone
                        foreach (var defId in matchedDefs)
                        {
                            try
                            {
                                var btr = (BlockTableRecord)tr.GetObject(defId, OpenMode.ForWrite, false);
                                if (btr != null && !btr.IsErased && !btr.IsLayout && !btr.IsDependent && !btr.IsFromExternalReference)
                                {
                                    btr.Erase();
                                    blockDefsErased++;
                                }
                            }
                            catch (System.Exception ex)
                            {
                                ed.WriteMessage($"\nFailed erasing block definition {defId}: {ex.Message}");
                            }
                        }
                    }

                    tr.Commit();
                }

                // 4) Freeze layers matching requested patterns
                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var lt = (LayerTable)tr.GetObject(db.LayerTableId, OpenMode.ForRead);
                    ObjectId zeroId = ObjectId.Null;
                    LayerTableRecord zeroLtr = null;
                    if (lt.Has("0"))
                    {
                        zeroId = lt["0"];
                        zeroLtr = (LayerTableRecord)tr.GetObject(zeroId, OpenMode.ForWrite);
                        if (zeroLtr.IsOff) zeroLtr.IsOff = false;
                        if (zeroLtr.IsFrozen) zeroLtr.IsFrozen = false;
                    }

                    foreach (ObjectId layerId in lt)
                    {
                        LayerTableRecord ltr = null;
                        try { ltr = (LayerTableRecord)tr.GetObject(layerId, OpenMode.ForWrite); }
                        catch { continue; }
                        if (ltr == null) continue;

                        string lname = (ltr.Name ?? string.Empty).ToLowerInvariant();
                        bool matchChristian = lname.Contains("christian");
                        bool matchWlSig = lname.Contains("wl") && lname.Contains("sig");
                        bool matchWLstamp = lname.Contains("wlstamp");
                        bool matchRev = lname.Contains("rev");
                        bool matchDelta = lname.Contains("delta");
                        if ((matchChristian || matchWlSig || matchWLstamp || matchRev || matchDelta) && !ltr.IsFrozen)
                        {
                            try
                            {
                                if (db.Clayer == layerId)
                                {
                                    if (!zeroId.IsNull && zeroId != layerId)
                                    {
                                        db.Clayer = zeroId;
                                    }
                                    else
                                    {
                                        // If we cannot change, skip freezing current layer
                                        continue;
                                    }
                                }
                                ltr.IsFrozen = true;
                                layersFrozen++;
                            }
                            catch (System.Exception ex)
                            {
                                ed.WriteMessage($"\nFailed to freeze layer '{ltr.Name}': {ex.Message}");
                            }
                        }
                    }

                    tr.Commit();
                }

                ed.WriteMessage($"\nDetached {dwgDetached} DWG XREF(s). Erased {imagesErased} image ref(s) and detached {imageDefsDetached} image def(s). Erased {blockRefsErased} block ref(s) and deleted {blockDefsErased} block def(s). Froze {layersFrozen} layer(s).");
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nDetach operation failed: {ex.Message}");
            }
        }
    }
}
```
===== END DetachSpecialXrefsCommand.cs =====

===== BEGIN DetectPaperSpaceXrefsCommand.cs =====
```csharp
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Globalization;

namespace AutoCADCleanupTool
{
    public partial class CleanupCommands
    {
        [CommandMethod("CLEANPS", CommandFlags.Modal)]
        public static void ListPaperSpaceXrefs()
        {
            Document doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            Database db = doc.Database;
            Editor ed = doc.Editor;

            ed.Regen();

            try
            {
                var entries = new List<XrefReportEntry>();

                using (Transaction tr = db.TransactionManager.StartTransaction())
                {
                    LayoutManager lm = LayoutManager.Current;
                    if (lm == null)
                    {
                        ed.WriteMessage("\r\nLayout manager is unavailable; cannot inspect paper space.");
                        tr.Commit();
                        return;
                    }

                    DBDictionary layoutDict = tr.GetObject(db.LayoutDictionaryId, OpenMode.ForRead) as DBDictionary;
                    if (layoutDict == null)
                    {
                        ed.WriteMessage("\r\nLayout dictionary is unavailable; cannot inspect paper space.");
                        tr.Commit();
                        return;
                    }

                    string drawingDirectory = GetDrawingDirectory(doc, db);

                    foreach (DBDictionaryEntry entry in layoutDict)
                    {
                        Layout layout = tr.GetObject(entry.Value, OpenMode.ForRead) as Layout;
                        if (layout == null || layout.ModelType) continue;

                        BlockTableRecord btr = tr.GetObject(layout.BlockTableRecordId, OpenMode.ForRead) as BlockTableRecord;
                        if (btr == null) continue;

                        foreach (ObjectId entId in btr)
                        {
                            if (!entId.IsValid) continue;

                            // Do NOT open ForWrite unless actually modifying — avoids dirtying extents after UNDO
                            BlockReference br = tr.GetObject(entId, OpenMode.ForRead, false) as BlockReference;
                            if (br == null) continue;

                            BlockTableRecord def = null;
                            try { def = tr.GetObject(br.BlockTableRecord, OpenMode.ForRead) as BlockTableRecord; }
                            catch { }
                            if (def == null) continue;

                            if (!def.IsFromExternalReference && !def.IsFromOverlayReference) continue;

                            string blockName = def.Name;
                            string layer = br.Layer;
                            string status = def.XrefStatus.ToString();
                            string rawPath = def.PathName ?? string.Empty;
                            string absolutePath = ResolveXrefPath(db, rawPath, drawingDirectory);

                            // Robust extents/footprint derivation — tolerant of UNDO wiping BR.GeometricExtents cache
                            Point3d[] footprint = null;
                            Extents3d? extents = null;

                            // 1) Try BR's own extents first
                            extents = TryGetExtents(br);

                            // 2) Try an orientation-aware footprint from the block contents (already world-space)
                            var orientedFootprint = BuildBlockFootprint(br, def, tr);
                            if (orientedFootprint != null)
                            {
                                footprint = orientedFootprint;
                                if (extents == null)
                                    extents = ExtentsFromPoints(orientedFootprint);
                            }

                            // 3) Still nothing? Transform definition extents by BR transform
                            if (extents == null)
                            {
                                var defExt = TryGetBlockDefExtents(def, tr);
                                if (defExt != null)
                                {
                                    var worldExt = defExt.Value;
                                    worldExt.TransformBy(br.BlockTransform);

                                    // Flatten Z for paper space usage
                                    extents = new Extents3d(
                                        new Point3d(worldExt.MinPoint.X, worldExt.MinPoint.Y, 0),
                                        new Point3d(worldExt.MaxPoint.X, worldExt.MaxPoint.Y, 0)
                                    );

                                    if (footprint == null)
                                        footprint = BuildRectangleFromExtents(extents.Value);
                                }
                            }

                            // 4) Last resort — rectangle from whatever extents we have
                            if (footprint == null && extents != null)
                            {
                                footprint = BuildRectangleFromExtents(extents.Value);
                            }

                            entries.Add(new XrefReportEntry(br.ObjectId, layout.LayoutName, blockName, layer, status, absolutePath, footprint, extents));
                        }
                    }

                    tr.Commit();
                }

                if (entries.Count == 0)
                {
                    ed.WriteMessage("\r\nNo external references were detected in paper space layouts.");
                    return;
                }

                ed.WriteMessage($"\r\nDetected {entries.Count} external reference insertion(s) in paper space.");

                var indexedEntries = entries
                    .Select((entry, idx) => new XrefReportItem(entry, idx + 1))
                    .ToList();

                var groupedByLayout = indexedEntries
                    .GroupBy(i => i.Entry.LayoutName, StringComparer.OrdinalIgnoreCase)
                    .OrderBy(g => g.Key, StringComparer.OrdinalIgnoreCase)
                    .ToList();

                int autoCleanedLayouts = 0;

                foreach (var group in groupedByLayout)
                {
                    if (group.Count() == 1)
                    {
                        var target = group.First();
                        if (target.Entry.Extents == null)
                        {
                            ed.WriteMessage($"\r\n  Layout: {group.Key}: Skipping automatic cleanup; extents not available for this XREF.");
                            continue;
                        }

                        int erased = TryEraseOutsideEntry(doc, ed, db, target);
                        if (erased >= 0)
                        {
                            autoCleanedLayouts++;
                            if (erased > 0)
                            {
                                ed.WriteMessage($"\r\n  Layout: {group.Key}: Removed paper space geometry outside the title block extents.");
                            }
                            else
                            {
                                ed.WriteMessage($"\r\n  Layout: {group.Key}: No paper space geometry outside the title block extents was detected.");
                            }
                        }
                    }
                    else
                    {
                        ed.WriteMessage($"\r\n  Layout: {group.Key} ({group.Count()} XREF(s)): Skipping automatic cleanup; multiple XREF block references detected on this layout.");
                    }
                }

                if (autoCleanedLayouts > 0)
                {
                    ed.WriteMessage($"\r\nAutomatically cleaned {autoCleanedLayouts} layout(s) containing a single XREF.");
                }
                else
                {
                    ed.WriteMessage("\r\nNo layouts were automatically cleaned.");
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\r\nFailed to enumerate paper space XREFs: {ex.Message}");
            }
        }

        private static bool EnsurePaperSpaceLayoutActive(Document doc, Editor ed, string layoutName)
        {
            try
            {
                LayoutManager lm = LayoutManager.Current;
                if (lm == null)
                {
                    ed.WriteMessage("\r\nLayout manager is unavailable; cannot activate paper space.");
                    return false;
                }

                if (doc.Database.TileMode)
                {
                    Autodesk.AutoCAD.ApplicationServices.Application.SetSystemVariable("TILEMODE", 0);
                }

                if (!string.IsNullOrWhiteSpace(layoutName) &&
                    !string.Equals(lm.CurrentLayout, layoutName, StringComparison.OrdinalIgnoreCase))
                {
                    lm.CurrentLayout = layoutName;
                }

                try { ed.SwitchToPaperSpace(); } catch { }
                try { Application.SetSystemVariable("CVPORT", 1); } catch { }

                return true;
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\r\nUnable to activate layout \"{layoutName}\": {ex.Message}");
                return false;
            }
        }

        private static int TryEraseOutsideEntry(Document doc, Editor ed, Database db, XrefReportItem target)
        {
            if (doc == null || ed == null || db == null || target == null || target.Entry.Extents == null)
                return -1;

            try
            {
                using (doc.LockDocument())
                {
                    if (!EnsurePaperSpaceLayoutActive(doc, ed, target.Entry.LayoutName))
                        return -1;

                    ObjectId layoutBtrId = GetLayoutBlockTableRecordId(db, target.Entry.LayoutName);
                    if (layoutBtrId.IsNull)
                    {
                        ed.WriteMessage($"\r\nUnable to locate layout \"{target.Entry.LayoutName}\" for cleanup.");
                        return -1;
                    }

                    Extents3d expanded = ExpandExtents(target.Entry.Extents.Value, 0.01);

                    var keepIds = new HashSet<ObjectId>();
                    if (target.Entry.BlockReferenceId != ObjectId.Null)
                        keepIds.Add(target.Entry.BlockReferenceId);

                    using (Transaction tr = db.TransactionManager.StartTransaction())
                    {
                        var btr = (BlockTableRecord)tr.GetObject(layoutBtrId, OpenMode.ForRead);
                        foreach (ObjectId entId in btr)
                        {
                            if (!entId.IsValid || keepIds.Contains(entId))
                                continue;

                            var ent = tr.GetObject(entId, OpenMode.ForRead) as Entity;
                            if (ent == null)
                                continue;

                            if (ent is Viewport vp && vp.Number == 1)
                            {
                                keepIds.Add(entId);
                                continue;
                            }

                            Extents3d? entExt = TryGetExtents(ent);
                            if (entExt != null && ExtentsIntersectsXY(expanded, entExt.Value, includeTouch: true))
                                keepIds.Add(entId);
                        }

                        tr.Commit();
                    }

                    if (keepIds.Count == 0)
                    {
                        ed.WriteMessage("\r\nErase skipped; no geometry detected within the title block bounds.");
                        return -1;
                    }

                    return EraseEntitiesExcept(db, ed, layoutBtrId, keepIds);
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\r\nFailed to erase geometry outside the title block: {ex.Message}");
                return -1;
            }
        }

        private static ObjectId GetLayoutBlockTableRecordId(Database db, string layoutName)
        {
            if (db == null || string.IsNullOrWhiteSpace(layoutName))
                return ObjectId.Null;

            try
            {
                using (Transaction tr = db.TransactionManager.StartTransaction())
                {
                    var layoutDict = (DBDictionary)tr.GetObject(db.LayoutDictionaryId, OpenMode.ForRead);
                    foreach (DBDictionaryEntry entry in layoutDict)
                    {
                        var layout = tr.GetObject(entry.Value, OpenMode.ForRead) as Layout;
                        if (layout != null && string.Equals(layout.LayoutName, layoutName, StringComparison.OrdinalIgnoreCase))
                        {
                            ObjectId result = layout.BlockTableRecordId;
                            tr.Commit();
                            return result;
                        }
                    }
                    tr.Commit();
                }
            }
            catch { }

            return ObjectId.Null;
        }

        private static string ResolveXrefPath(Database db, string rawPath, string drawingDirectory)
        {
            if (string.IsNullOrWhiteSpace(rawPath))
                return string.Empty;

            try
            {
                string candidate = rawPath;
                if (!Path.IsPathRooted(candidate))
                {
                    if (!string.IsNullOrWhiteSpace(drawingDirectory))
                        candidate = Path.Combine(drawingDirectory, candidate);

                    if (!Path.IsPathRooted(candidate) && db != null)
                    {
                        try
                        {
                            string found = HostApplicationServices.Current?.FindFile(rawPath, db, FindFileHint.Default);
                            if (!string.IsNullOrWhiteSpace(found))
                                candidate = found;
                        }
                        catch { }
                    }

                    if (!Path.IsPathRooted(candidate))
                        return rawPath;
                }

                return Path.GetFullPath(candidate);
            }
            catch
            {
                return rawPath;
            }
        }

        private static string GetDrawingDirectory(Document doc, Database db)
        {
            try
            {
                if (doc != null && !string.IsNullOrWhiteSpace(doc.Name))
                {
                    string docDir = Path.GetDirectoryName(doc.Name);
                    if (!string.IsNullOrWhiteSpace(docDir))
                        return docDir;
                }

                if (db != null && !string.IsNullOrWhiteSpace(db.Filename))
                {
                    string dbDir = Path.GetDirectoryName(db.Filename);
                    if (!string.IsNullOrWhiteSpace(dbDir))
                        return dbDir;
                }
            }
            catch { }

            return string.Empty;
        }

        private static Point3d[] BuildRectangleFromExtents(Extents3d ext)
        {
            double width = Math.Abs(ext.MaxPoint.X - ext.MinPoint.X);
            double height = Math.Abs(ext.MaxPoint.Y - ext.MinPoint.Y);
            const double minSize = 1e-6;
            if (width < minSize || height < minSize)
                return null;

            return new[]
            {
                new Point3d(ext.MinPoint.X, ext.MinPoint.Y, 0),
                new Point3d(ext.MaxPoint.X, ext.MinPoint.Y, 0),
                new Point3d(ext.MaxPoint.X, ext.MaxPoint.Y, 0),
                new Point3d(ext.MinPoint.X, ext.MaxPoint.Y, 0)
            };
        }

        private static Point3d[] BuildBlockFootprint(BlockReference br, BlockTableRecord def, Transaction tr)
        {
            if (br == null || def == null || tr == null)
                return null;

            try
            {
                Extents3d? localExtents = null;

                foreach (ObjectId id in def)
                {
                    if (!id.IsValid) continue;

                    Entity ent = null;
                    try { ent = tr.GetObject(id, OpenMode.ForRead, false) as Entity; }
                    catch { }
                    if (ent == null) continue;

                    var entExt = TryGetExtents(ent);
                    if (entExt == null) continue;

                    if (localExtents == null)
                        localExtents = entExt.Value;
                    else
                    {
                        var agg = localExtents.Value;
                        agg.AddExtents(entExt.Value);
                        localExtents = agg;
                    }
                }

                if (localExtents == null)
                    return null;

                var ext = localExtents.Value;
                double width = Math.Abs(ext.MaxPoint.X - ext.MinPoint.X);
                double height = Math.Abs(ext.MaxPoint.Y - ext.MinPoint.Y);
                if (width < 1e-6 || height < 1e-6)
                    return null;

                Matrix3d transform = br.BlockTransform;
                var corners = new Point3d[4];
                corners[0] = new Point3d(ext.MinPoint.X, ext.MinPoint.Y, ext.MinPoint.Z).TransformBy(transform);
                corners[1] = new Point3d(ext.MaxPoint.X, ext.MinPoint.Y, ext.MinPoint.Z).TransformBy(transform);
                corners[2] = new Point3d(ext.MaxPoint.X, ext.MaxPoint.Y, ext.MaxPoint.Z).TransformBy(transform);
                corners[3] = new Point3d(ext.MinPoint.X, ext.MaxPoint.Y, ext.MaxPoint.Z).TransformBy(transform);

                // flatten Z for paper space
                for (int i = 0; i < corners.Length; i++)
                    corners[i] = new Point3d(corners[i].X, corners[i].Y, 0.0);

                return corners;
            }
            catch
            {
                return null;
            }
        }

        private static string FormatPoint2D(Point3d pt)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0:F4}, {1:F4}", pt.X, pt.Y);
        }

        private static string DescribeExtents2D(Extents3d ext)
        {
            double width = Math.Abs(ext.MaxPoint.X - ext.MinPoint.X);
            double height = Math.Abs(ext.MaxPoint.Y - ext.MinPoint.Y);
            return string.Format(CultureInfo.InvariantCulture,
                "min ({0}) max ({1}) | width={2:F4}, height={3:F4}",
                FormatPoint2D(ext.MinPoint),
                FormatPoint2D(ext.MaxPoint),
                width,
                height);
        }

        private sealed class XrefReportEntry
        {
            public XrefReportEntry(ObjectId blockId, string layoutName, string blockName, string layer, string status, string path, Point3d[] footprint, Extents3d? extents)
            {
                BlockReferenceId = blockId;
                LayoutName = layoutName;
                BlockName = blockName;
                Layer = layer;
                Status = status;
                Path = path;
                Footprint = footprint;
                Extents = extents;
            }

            public ObjectId BlockReferenceId { get; }
            public string LayoutName { get; }
            public string BlockName { get; }
            public string Layer { get; }
            public string Status { get; }
            public string Path { get; }
            public Point3d[] Footprint { get; }
            public Extents3d? Extents { get; }
            public bool HasZoomTarget => Footprint != null && Footprint.Length == 4;
        }

        private sealed class XrefReportItem
        {
            public XrefReportItem(XrefReportEntry entry, int index)
            {
                Entry = entry;
                Index = index;
            }

            public XrefReportEntry Entry { get; }
            public int Index { get; }
        }

        // ---------- NEW HELPERS (robust extents fallbacks) ----------
        private static Extents3d? ExtentsFromPoints(Point3d[] pts)
        {
            if (pts == null || pts.Length == 0) return null;
            double minX = pts[0].X, minY = pts[0].Y, maxX = pts[0].X, maxY = pts[0].Y;
            for (int i = 1; i < pts.Length; i++)
            {
                if (pts[i].X < minX) minX = pts[i].X;
                if (pts[i].Y < minY) minY = pts[i].Y;
                if (pts[i].X > maxX) maxX = pts[i].X;
                if (pts[i].Y > maxY) maxY = pts[i].Y;
            }
            return new Extents3d(new Point3d(minX, minY, 0), new Point3d(maxX, maxY, 0));
        }

        // Keep if the two AABBs overlap in XY (touching counts as overlap)
        private static bool ExtentsIntersectsXY(Extents3d a, Extents3d b, bool includeTouch = true, double tol = 1e-6)
        {
            // Flatten Z (defensive; your extents are already flattened elsewhere)
            var aMinX = Math.Min(a.MinPoint.X, a.MaxPoint.X);
            var aMaxX = Math.Max(a.MinPoint.X, a.MaxPoint.X);
            var aMinY = Math.Min(a.MinPoint.Y, a.MaxPoint.Y);
            var aMaxY = Math.Max(a.MinPoint.Y, a.MaxPoint.Y);

            var bMinX = Math.Min(b.MinPoint.X, b.MaxPoint.X);
            var bMaxX = Math.Max(b.MinPoint.X, b.MaxPoint.X);
            var bMinY = Math.Min(b.MinPoint.Y, b.MaxPoint.Y);
            var bMaxY = Math.Max(b.MinPoint.Y, b.MaxPoint.Y);

            if (includeTouch)
            {
                return (aMinX <= bMaxX + tol) && (aMaxX + tol >= bMinX) &&
                       (aMinY <= bMaxY + tol) && (aMaxY + tol >= bMinY);
            }
            else
            {
                return (aMinX < bMaxX - tol) && (aMaxX - tol > bMinX) &&
                       (aMinY < bMaxY - tol) && (aMaxY - tol > bMinY);
            }
        }


        private static Extents3d? TryGetBlockDefExtents(BlockTableRecord def, Transaction tr)
        {
            if (def == null || tr == null) return null;

            Extents3d? localExtents = null;
            foreach (ObjectId id in def)
            {
                if (!id.IsValid) continue;

                Entity ent = null;
                try { ent = tr.GetObject(id, OpenMode.ForRead, false) as Entity; }
                catch { }
                if (ent == null) continue;

                var eext = TryGetExtents(ent);
                if (eext == null) continue;

                if (localExtents == null)
                    localExtents = eext.Value;
                else
                {
                    var agg = localExtents.Value;
                    agg.AddExtents(eext.Value);
                    localExtents = agg;
                }
            }
            return localExtents;
        }
    }
}
```
===== END DetectPaperSpaceXrefsCommand.cs =====

===== BEGIN EmbedFromXrefsCommand.cs =====
```csharp
﻿using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices; // Recommended for releasing COM objects

namespace AutoCADCleanupTool
{
    public partial class SimplerCommands
    {
        [CommandMethod("EMBEDFROMXREFS", CommandFlags.Modal)]
        public static void EmbedFromXrefs()
        {
            var doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            var db = doc.Database;
            var ed = doc.Editor;

            ed.WriteMessage("\n--- Starting EMBEDFROMXREFS ---");

            // --- Phase 1: Preparation ---

            _pending.Clear();
            _lastPastedOle = ObjectId.Null;

            try
            {
                DeleteOldEmbedTemps(daysOld: 7);
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\n[Warning] Could not delete old temp files: {ex.Message}");
            }

            // --- Phase 2: Image Collection and Processing ---
            ObjectId originalClayer = ObjectId.Null;
            try
            {
                // Ensure layer "0" is thawed and set current, saving the original layer
                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var lt = (LayerTable)tr.GetObject(db.LayerTableId, OpenMode.ForRead);
                    if (lt.Has("0"))
                    {
                        var zeroId = lt["0"];
                        var zeroLtr = (LayerTableRecord)tr.GetObject(zeroId, OpenMode.ForWrite);
                        if (zeroLtr.IsFrozen)
                        {
                            ed.WriteMessage("\nThawing layer '0'.");
                            zeroLtr.IsFrozen = false;
                        }
                        originalClayer = db.Clayer; // Save original layer
                        if (_savedClayer.IsNull) _savedClayer = originalClayer; // Assuming _savedClayer is part of your class
                        db.Clayer = zeroId;
                    }
                    tr.Commit();
                }

                // Collect and pre-process all raster images
                CollectAndPreflightImages(doc);
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\n[!] A critical error occurred during image collection: {ex.Message}");
                // On failure, restore state and exit
                RestoreOriginalLayer(db, originalClayer);
                return;
            }

            // --- Phase 3: Embedding Logic ---
            if (_pending.Count == 0)
            {
                ed.WriteMessage("\nNo valid raster images found to embed.");
                ClosePowerPoint(ed); // Ensure PPT is closed if not needed
                RestoreOriginalLayer(db, originalClayer);

                if (_chainFinalizeAfterEmbed)
                {
                    _chainFinalizeAfterEmbed = false;
                    doc.SendStringToExecute("_.FINALIZE ", true, false, false);
                }
                return;
            }

            ed.WriteMessage($"\nSuccessfully queued {_pending.Count} image(s).");

            try
            {
                if (!EnsurePowerPoint(ed))
                {
                    ed.WriteMessage("\n[!] Failed to start or connect to PowerPoint. Aborting.");
                    RestoreOriginalLayer(db, originalClayer);
                    return;
                }

                if (WindowOrchestrator.TryGetPowerPointHwnd(out var pptHwnd))
                {
                    WindowOrchestrator.EnsureSeparationOrSafeOverlap(ed, pptHwnd, preferDifferentMonitor: true);
                }

                AttachHandlers(db, doc);
                ed.WriteMessage($"\nStarting paste process for {_pending.Count} raster image(s)...");
                ProcessNextPaste(doc, ed);
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\n[!] An error occurred during the PowerPoint embedding process: {ex.Message}");
                ClosePowerPoint(ed);
                RestoreOriginalLayer(db, originalClayer);
            }
        }

        private static void CollectAndPreflightImages(Document doc)
        {
            var db = doc.Database;
            var ed = doc.Editor;
            int queuedCount = 0;

            using (var tr = db.TransactionManager.StartTransaction())
            {
                var space = (BlockTableRecord)tr.GetObject(db.CurrentSpaceId, OpenMode.ForRead);

                foreach (ObjectId id in space)
                {
                    if (id.ObjectClass.DxfName.ToUpperInvariant() != "IMAGE") continue;

                    var img = tr.GetObject(id, OpenMode.ForRead) as RasterImage;
                    if (img == null || img.ImageDefId.IsNull) continue;

                    var def = tr.GetObject(img.ImageDefId, OpenMode.ForRead) as RasterImageDef;
                    if (def == null) continue;

                    string resolved = ResolveImagePath(db, def.SourceFileName);
                    if (string.IsNullOrWhiteSpace(resolved) || !File.Exists(resolved))
                    {
                        ed.WriteMessage($"\nSkipping missing image: {def.SourceFileName}");
                        continue;
                    }

                    string safePath = null;
                    try
                    {
                        ed.WriteMessage($"\nProcessing: {Path.GetFileName(resolved)}...");
                        safePath = PreflightRasterForPpt(resolved);
                    }
                    catch (System.Exception pex)
                    {
                        ed.WriteMessage($"\n[!] PREFLIGHT FAILED for '{Path.GetFileName(resolved)}': {pex.Message} — skipping this image.");
                        continue;
                    }

                    if (string.IsNullOrEmpty(safePath))
                    {
                        ed.WriteMessage($"\n[!] Preflight returned an empty path for '{Path.GetFileName(resolved)}'. Skipping.");
                        continue;
                    }

                    var cs = img.Orientation;
                    var placement = new ImagePlacement
                    {
                        Path = safePath,
                        Pos = cs.Origin,
                        U = cs.Xaxis,
                        V = cs.Yaxis,
                        ImageId = img.ObjectId,
                    };

                    _pending.Enqueue(placement);
                    queuedCount++;
                    ed.WriteMessage($"\nQueued [{queuedCount}]: {Path.GetFileName(placement.Path)}");
                }
                tr.Commit();
            }
        }

        /// <summary>
        /// Safely restores the original current layer.
        /// </summary>
        private static void RestoreOriginalLayer(Database db, ObjectId originalClayer)
        {
            if (db != null && !originalClayer.IsNull && db.Clayer != originalClayer)
            {
                try
                {
                    db.Clayer = originalClayer;
                }
                catch (System.Exception ex)
                {
                    Application.DocumentManager.MdiActiveDocument.Editor.WriteMessage($"\nCould not restore original layer: {ex.Message}");
                }
            }
        }

        private static bool TryGetTitleBlockOutlinePointsForEmbed(Database db, out Point3d[] poly)
        {
            poly = null;
            try
            {
                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var lm = LayoutManager.Current;
                    if (lm == null) return false;

                    var layId = lm.GetLayoutId(lm.CurrentLayout);
                    var layout = (Layout)tr.GetObject(layId, OpenMode.ForRead);

                    var psId = layout.BlockTableRecordId;
                    var psBtr = (BlockTableRecord)tr.GetObject(psId, OpenMode.ForRead);

                    string[] hints = { "x-tb", "title", "tblock", "border", "sheet" };
                    BlockReference best = null;
                    double bestArea = 0;

                    foreach (ObjectId id in psBtr)
                    {
                        var br = tr.GetObject(id, OpenMode.ForRead) as BlockReference;
                        if (br == null) continue;

                        string name = null;
                        try
                        {
                            if (br.IsDynamicBlock)
                            {
                                var dyn = (BlockTableRecord)tr.GetObject(br.DynamicBlockTableRecord, OpenMode.ForRead);
                                name = dyn?.Name;
                            }
                            else
                            {
                                var btr = (BlockTableRecord)tr.GetObject(br.BlockTableRecord, OpenMode.ForRead);
                                name = btr?.Name;
                            }
                        }
                        catch { }

                        if (string.IsNullOrEmpty(name)) continue;

                        var lname = name.ToLowerInvariant();
                        bool matches = false;
                        foreach (var h in hints) { if (lname.Contains(h)) { matches = true; break; } }
                        if (!matches) continue;

                        Extents3d ext;
                        try { ext = br.GeometricExtents; } catch { continue; }

                        double area = Math.Abs((ext.MaxPoint.X - ext.MinPoint.X) * (ext.MaxPoint.Y - ext.MinPoint.Y));
                        if (area > bestArea)
                        {
                            best = br;
                            bestArea = area;
                        }
                    }

                    if (best != null)
                    {
                        var ex = best.GeometricExtents;
                        var pmin = ex.MinPoint;
                        var pmax = ex.MaxPoint;

                        poly = new[]
                        {
                            new Point3d(pmin.X, pmin.Y, 0), new Point3d(pmax.X, pmin.Y, 0),
                            new Point3d(pmax.X, pmax.Y, 0), new Point3d(pmin.X, pmax.Y, 0)
                        };
                        return true;
                    }

                    var pMin = db.Pextmin;
                    var pMax = db.Pextmax;
                    poly = new[]
                    {
                        new Point3d(pMin.X, pMin.Y, 0), new Point3d(pMax.X, pMin.Y, 0),
                        new Point3d(pMax.X, pMax.Y, 0), new Point3d(pMin.X, pMax.Y, 0)
                    };
                    return true;
                }
            }
            catch { return false; }
        }

        private static void ZoomToTitleBlockForEmbed(Editor ed, Point3d[] poly)
        {
            if (ed == null || poly == null || poly.Length < 2) return;
            try
            {
                var ext = new Extents3d(poly[0], poly[1]);
                for (int i = 2; i < poly.Length; i++) ext.AddPoint(poly[i]);

                double margin = Math.Max(ext.MaxPoint.X - ext.MinPoint.X, ext.MaxPoint.Y - ext.MinPoint.Y) * 0.05;

                Point3d pMin = new Point3d(ext.MinPoint.X - margin, ext.MinPoint.Y - margin, 0);
                Point3d pMax = new Point3d(ext.MaxPoint.X + margin, ext.MaxPoint.Y + margin, 0);

                using (var view = ed.GetCurrentView())
                {
                    view.Width = pMax.X - pMin.X;
                    view.Height = pMax.Y - pMin.Y;
                    view.CenterPoint = new Point2d((pMin.X + pMax.X) / 2.0, (pMin.Y + pMax.Y) / 2.0);
                    ed.SetCurrentView(view);
                }
                ed.Regen();
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nError during zoom: {ex.Message}");
            }
        }

        private static string PreflightRasterForPpt(string srcPath)
        {
            string tempDir = Path.Combine(Path.GetTempPath(), "AutoCADCleanupTool", "embed");
            Directory.CreateDirectory(tempDir);
            // Add a unique identifier to prevent file collisions from different drawings with same image name
            string outPath = Path.Combine(
                tempDir,
                Path.GetFileNameWithoutExtension(srcPath) + "_ppt_" + Guid.NewGuid().ToString("N").Substring(0, 8) + ".png"
            );

            using (var orig = System.Drawing.Image.FromFile(srcPath))
            {
                try
                {
                    var fd = new FrameDimension(orig.FrameDimensionsList[0]);
                    if (orig.GetFrameCount(fd) > 1)
                        orig.SelectActiveFrame(fd, 0);
                }
                catch { /* not multi-frame; ignore */ }

                int maxSide = 8000;
                int w = orig.Width, h = orig.Height;
                double scale = 1.0;
                if (Math.Max(w, h) > maxSide)
                    scale = (double)maxSide / Math.Max(w, h);

                int targetW = Math.Max(1, (int)Math.Round(w * scale));
                int targetH = Math.Max(1, (int)Math.Round(h * scale));

                using (var bmp = new Bitmap(targetW, targetH, PixelFormat.Format32bppArgb))
                using (var g = Graphics.FromImage(bmp))
                {
                    g.Clear(System.Drawing.Color.Transparent);
                    g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                    g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;
                    g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;
                    g.DrawImage(orig, new Rectangle(0, 0, targetW, targetH));
                    bmp.Save(outPath, ImageFormat.Png);
                }
            }

            return outPath;
        }

        private static void DeleteOldEmbedTemps(int daysOld = 7)
        {
            string tempDir = Path.Combine(Path.GetTempPath(), "AutoCADCleanupTool", "embed");
            if (!Directory.Exists(tempDir)) return;

            var cutoff = DateTime.Now.AddDays(-Math.Abs(daysOld));
            foreach (var f in Directory.EnumerateFiles(tempDir, "*.png"))
            {
                try
                {
                    var info = new FileInfo(f);
                    if (info.LastWriteTime < cutoff) info.Delete();
                }
                catch { /* ignore; file might be in use */ }
            }
        }
    }
}
```
===== END EmbedFromXrefsCommand.cs =====

===== BEGIN EraseOtherCommand.cs =====
```csharp
﻿using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using System;
using System.Collections.Generic;

namespace AutoCADCleanupTool
{
    public partial class SimplerCommands
    {
        // The CommandFlags.UsePickSet flag tells AutoCAD that this command
        // is aware of and can use the pre-selected "PickFirst" set.
        [CommandMethod("EraseOther", CommandFlags.UsePickSet)]
        public static void EraseOtherCommand()
        {
            Document doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            Database db = doc.Database;
            Editor ed = doc.Editor;

            PromptSelectionResult psr;

            // Step 1: Use SelectImplied() to get the pre-selected ("PickFirst") set.
            psr = ed.SelectImplied();

            // If the status is not OK, it means nothing was pre-selected.
            // In this case, we fall back to prompting the user for a new selection.
            if (psr.Status != PromptStatus.OK)
            {
                PromptSelectionOptions pso = new PromptSelectionOptions();
                pso.MessageForAdding = "\\nSelect objects to keep: ";
                psr = ed.GetSelection(pso);
            }

            // If the user cancelled or made an empty selection at any point, exit.
            if (psr.Status != PromptStatus.OK)
            {
                return;
            }

            // Create a HashSet for fast lookups of the objects we want to keep.
            var idsToKeep = new HashSet<ObjectId>(psr.Value.GetObjectIds());
            int erasedCount = 0;

            using (Transaction trans = db.TransactionManager.StartTransaction())
            {
                try
                {
                    BlockTableRecord currentSpace = trans.GetObject(db.CurrentSpaceId, OpenMode.ForRead) as BlockTableRecord;

                    var layersToUnlock = new HashSet<ObjectId>();
                    var idsToErase = new List<ObjectId>();

                    // Iterate through the current space to find objects to erase.
                    foreach (ObjectId id in currentSpace)
                    {
                        if (idsToKeep.Contains(id))
                        {
                            continue; // Skip objects in our "keep" list.
                        }

                        Entity ent = trans.GetObject(id, OpenMode.ForRead) as Entity;
                        if (ent != null)
                        {
                            idsToErase.Add(id);
                            LayerTableRecord layer = trans.GetObject(ent.LayerId, OpenMode.ForRead) as LayerTableRecord;
                            if (layer != null && layer.IsLocked)
                            {
                                layersToUnlock.Add(ent.LayerId);
                            }
                        }
                    }

                    // Temporarily unlock any locked layers.
                    foreach (ObjectId layerId in layersToUnlock)
                    {
                        LayerTableRecord layer = trans.GetObject(layerId, OpenMode.ForWrite) as LayerTableRecord;
                        layer.IsLocked = false;
                    }

                    // Erase the objects.
                    foreach (ObjectId idToErase in idsToErase)
                    {
                        Entity entToErase = trans.GetObject(idToErase, OpenMode.ForWrite) as Entity;
                        entToErase.Erase();
                        erasedCount++;
                    }

                    // Re-lock the layers that we unlocked.
                    foreach (ObjectId layerId in layersToUnlock)
                    {
                        LayerTableRecord layer = trans.GetObject(layerId, OpenMode.ForWrite) as LayerTableRecord;
                        layer.IsLocked = true;
                    }

                    trans.Commit();
                }
                catch (System.Exception ex)
                {
                    ed.WriteMessage($"\\nAn error occurred: {ex.Message}");
                    trans.Abort();
                }
            }

            if (erasedCount > 0)
            {
                ed.WriteMessage($"\\nErased {erasedCount} object(s).");
                ed.Regen();
            }
        }
    }
}
```
===== END EraseOtherCommand.cs =====

===== BEGIN FinalizeCleanupCommand.cs =====
```csharp
﻿using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AutoCADCleanupTool
{
    public partial class CleanupCommands
    {
        // STAGE 2: Erase images, build the "kill list", and detach ghost XREF blocks.
        [CommandMethod("-FINALIZE-CLEANUP", CommandFlags.Modal)]
        public static void FinalizeCleanupCommand()
        {
            Document doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            Database db = doc.Database;
            Editor ed = doc.Editor;
        
            ed.WriteMessage("\n--- Stage 2: Erasing images and detaching ghost XREF blocks... ---");
        
            try
            {
                using (Transaction trans = db.TransactionManager.StartTransaction())
                {
                    var newBlockIds = new List<ObjectId>();
                    BlockTable bt = trans.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable;
                    foreach (ObjectId currentBtrId in bt)
                    {
                        if (!_blockIdsBeforeBind.Contains(currentBtrId))
                        {
                            newBlockIds.Add(currentBtrId);
                        }
                    }
                    ed.WriteMessage($"\nFound {newBlockIds.Count} new block definition(s) created by bind.");

                    bool createdNewBlocks = newBlockIds.Count > 0;
                    int imagesErased = 0;
                    foreach (ObjectId newBtrId in newBlockIds)
                    {
                        BlockTableRecord newBtr = trans.GetObject(newBtrId, OpenMode.ForRead) as BlockTableRecord;
                        foreach (ObjectId entId in newBtr)
                        {
                            if (entId.ObjectClass.DxfName == "IMAGE")
                            {
                                RasterImage image = trans.GetObject(entId, OpenMode.ForWrite) as RasterImage;
                                if (image != null && !image.ImageDefId.IsNull)
                                {
                                    _imageDefsToPurge.Add(image.ImageDefId); // Add the definition to our kill list
                                }
                                image.Erase();
                                imagesErased++;
                            }
                        }
                    }
                    ed.WriteMessage($"\nErased {imagesErased} RasterImage entit(ies) and added {_imageDefsToPurge.Count} definitions to kill list.");

                    int ghostsDetached = 0;
                    if (createdNewBlocks || ForceDetachOriginalXrefs)
                    {
                        foreach (ObjectId originalXrefId in _originalXrefIds)
                        {
                            var btr = trans.GetObject(originalXrefId, OpenMode.ForRead, false, true) as BlockTableRecord;
                            if (btr == null || btr.IsErased)
                            {
                                continue;
                            }
                            if (!btr.IsFromExternalReference)
                            {
                                continue;
                            }
                            try
                            {
                                db.DetachXref(originalXrefId);
                                ghostsDetached++;
                            }
                            catch (System.Exception exDetach)
                            {
                                ed.WriteMessage($"\nFailed to detach XREF '{btr.Name}': {exDetach.Message}");
                            }
                        }
                        ed.WriteMessage($"\nManually detached {ghostsDetached} old XREF block definition(s).");
                    }
                    else
                    {
                        ed.WriteMessage($"\nNo new block definitions were created during bind; skipping XREF detachment.");
                    }

                    trans.Commit();
                }
        
                ed.WriteMessage("\nIntermediate cleanup complete. Queueing final surgical purge...");
                doc.SendStringToExecute("_-FINALIZE-PURGEDEFS ", true, false, false);
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nAn error occurred during cleanup: {ex.Message}\n{ex.StackTrace}");
            }
            finally
            {
                _blockIdsBeforeBind.Clear();
                _originalXrefIds.Clear();
                ForceDetachOriginalXrefs = false;
            }
        }
    }
}
```
===== END FinalizeCleanupCommand.cs =====

===== BEGIN FinalizeDrawingCommand.cs =====
```csharp
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AutoCADCleanupTool
{
    public partial class CleanupCommands
    {
        // STAGE 1: Get snapshots, bind, and queue the main cleanup command.
        [CommandMethod("FINALIZE")]
        public static void FinalizeDrawingCommand()
        {
            Document doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            Database db = doc.Database;
            Editor ed = doc.Editor;
        
            _blockIdsBeforeBind.Clear();
            _originalXrefIds.Clear();
            _imageDefsToPurge.Clear();
            ed.WriteMessage("\n--- Stage 1: Analyzing and Binding... ---");
        
            try
            {
                int bindCount = 0;
                using (Transaction trans = db.TransactionManager.StartTransaction())
                {
                    BlockTable bt = trans.GetObject(db.BlockTableId, OpenMode.ForRead) as BlockTable;
                    foreach (ObjectId btrId in bt)
                    {
                        _blockIdsBeforeBind.Add(btrId);
                        var btr = trans.GetObject(btrId, OpenMode.ForRead) as BlockTableRecord;
                        if (btr == null || !btr.IsFromExternalReference || !btr.IsResolved)
                        {
                            continue;
                        }

                        bool isDwg = false;
                        string pathName = btr.PathName ?? string.Empty;
                        if (!string.IsNullOrEmpty(pathName))
                        {
                            try { isDwg = string.Equals(Path.GetExtension(pathName), ".dwg", StringComparison.OrdinalIgnoreCase); }
                            catch { }
                        }

                        if (!isDwg)
                        {
                            string name = btr.Name ?? string.Empty;
                            isDwg = name.EndsWith(".dwg", StringComparison.OrdinalIgnoreCase);
                        }

                        if (isDwg)
                        {
                            _originalXrefIds.Add(btrId);
                        }
                    }

                    trans.Commit();
                }

                ed.WriteMessage($"\nFound {_blockIdsBeforeBind.Count} total blocks and {_originalXrefIds.Count} DWG XREFs to bind.");

                if (_originalXrefIds.Count > 0)
                {
                    var idsToBind = new ObjectIdCollection(_originalXrefIds.ToArray());
                    if (!SkipBindDuringFinalize)
                    {
                        ed.WriteMessage($"\nBinding {idsToBind.Count} DWG reference(s)...");
                        db.BindXrefs(idsToBind, true);
                        bindCount = idsToBind.Count;
                    }
                    else
                    {
                        ed.WriteMessage("\nSkipping XREF binding per configuration; will detach originals only.");
                    }
                }

                if (bindCount > 0)
                {
                    ed.WriteMessage("\nBind complete. Queueing cleanup process...");
                    doc.SendStringToExecute("_-FINALIZE-CLEANUP ", true, false, false);
                }
                else
                {
                    ed.WriteMessage("\nNo bindable DWG references found.");
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nAn error occurred during bind: {ex.Message}");
            }
            finally
            {
                SkipBindDuringFinalize = false;
            }
        }
    }
}
```
===== END FinalizeDrawingCommand.cs =====

===== BEGIN FinalizePurgeDefsCommand.cs =====
```csharp
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AutoCADCleanupTool
{
    public partial class CleanupCommands
    {
        // STAGE 3: Surgically remove the image definitions from our kill list.
        [CommandMethod("-FINALIZE-PURGEDEFS", CommandFlags.Modal)]
        public static void FinalizePurgeDefsCommand()
        {
            Document doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            Database db = doc.Database;
            Editor ed = doc.Editor;
        
            ed.WriteMessage("\n--- Stage 3: Surgically removing orphaned image definitions... ---");
            if (_imageDefsToPurge.Count == 0)
            {
                ed.WriteMessage("\nNo orphaned image definitions were identified. Finalization complete.");
                TriggerKeepOnlyTitleBlockIfRequested(doc, ed);
                return;
            }
        
            try
            {
                using (Transaction trans = db.TransactionManager.StartTransaction())
                {
                    int defsPurged = 0;
                    DBDictionary namedObjectsDict = trans.GetObject(db.NamedObjectsDictionaryId, OpenMode.ForRead) as DBDictionary;
                    if (namedObjectsDict.Contains("ACAD_IMAGE_DICT"))
                    {
                        DBDictionary imageDict = trans.GetObject(namedObjectsDict.GetAt("ACAD_IMAGE_DICT"), OpenMode.ForWrite) as DBDictionary;
                        var entriesToRemove = new Dictionary<string, ObjectId>();
        
                        // Find the dictionary keys for the defs on our kill list
                        foreach (DBDictionaryEntry entry in imageDict)
                        {
                            if (_imageDefsToPurge.Contains(entry.Value))
                            {
                                entriesToRemove.Add(entry.Key, entry.Value);
                            }
                        }
                        
                        ed.WriteMessage($"\nFound {entriesToRemove.Count} dictionary entr(ies) to remove.");
                        foreach (var item in entriesToRemove)
                        {
                            ed.WriteMessage($"\n  - Detaching and Erasing: {item.Key}");
                            imageDict.Remove(item.Key);
                            DBObject imageDef = trans.GetObject(item.Value, OpenMode.ForWrite);
                            imageDef.Erase();
                            defsPurged++;
                        }
                    }
                    ed.WriteMessage($"\nSuccessfully purged {defsPurged} image definition(s).");
                    trans.Commit();
                }
                ed.WriteMessage("\n-------------------------------------------------");
                ed.WriteMessage("\nFinalization Complete. Please save the drawing.");
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nAn error occurred during final purge: {ex.Message}\n{ex.StackTrace}");
            }
            finally
            {
                _imageDefsToPurge.Clear();
                TriggerKeepOnlyTitleBlockIfRequested(doc, ed);
            }
        }

        private static void TriggerKeepOnlyTitleBlockIfRequested(Document doc, Editor ed)
        {
            if (!RunKeepOnlyAfterFinalize) return;
            RunKeepOnlyAfterFinalize = false;
            try
            {
                doc.SendStringToExecute("_.KEEPONLYTITLEBLOCKMS ", true, false, false);
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nFailed to queue KEEPONLYTITLEBLOCKMS: {ex.Message}");
            }
        }
    }
}
```
===== END FinalizePurgeDefsCommand.cs =====

===== BEGIN FindTitleBlockCommand.cs =====
```csharp
﻿using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AutoCADCleanupTool
{
    public partial class CleanupCommands
    {
        // Utility: Find likely title block rectangle in THIS drawing's Model Space
        [CommandMethod("FINDTITLEBLOCKMS", CommandFlags.Modal)]
        public static void FindTitleBlockInModelSpace()
        {
            Document doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            Database db = doc.Database;
            Editor ed = doc.Editor;
        
            // Tokens to tailor as needed for your standards
            string[] layerTokens = { "TITLE", "TBLK", "BORDER", "SHEET", "FRAME" };
            var attrTags = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "SHEET", "SHEETNO", "SHEET_NO", "SHEETNUMBER", "DWG", "DWG_NO",
                "DRAWN", "CHECKED", "APPROVED", "PROJECT", "CLIENT", "SCALE", "DATE",
                "REV", "REVISION", "TITLE"
            };
        
            try
            {
                using (Transaction tr = db.TransactionManager.StartTransaction())
                {
                    BlockTable bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead);
                    BlockTableRecord ms = (BlockTableRecord)tr.GetObject(bt[BlockTableRecord.ModelSpace], OpenMode.ForRead);
                    if (db.CurrentSpaceId != ms.ObjectId)
                    {
                        ed.WriteMessage("\nPlease switch to Model Space before running KEEPONLYTITLEBLOCKMS.");
                        tr.Commit();
                        return;
                    }
        
                    // Collect attribute definitions present in Model Space (common in TB source files)
                    var attDefs = new List<(Point3d Pos, string Tag)>();
                    foreach (ObjectId id in ms)
                    {
                        if (!id.IsValid) continue;
                        DBObject dbo = tr.GetObject(id, OpenMode.ForRead, false);
                        if (dbo is AttributeDefinition ad && !ad.Invisible)
                        {
                            attDefs.Add((ad.Position, ad.Tag));
                        }
                    }
        
                    // Scan for rectangular closed polylines and score them
                    var candidates = new List<(Entity Ent, Extents3d Ext, double Score, double Angle)>();
                    foreach (ObjectId id in ms)
                    {
                        if (!id.IsValid) continue;
                        Entity ent = tr.GetObject(id, OpenMode.ForRead, false) as Entity;
                        if (ent == null) continue;
        
                        Extents3d? ext = TryGetExtents(ent);
                        if (ext == null) continue;
        
                        double score = 0.0;
                        double angle = 0.0;
        
                        // Layer hint
                        if (layerTokens.Any(t => ent.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0))
                            score += 0.8;
        
                        // Prefer clean rectangles (closed lwpolyline with 4 verts)
                        if (ent is Polyline pl && pl.Closed && pl.NumberOfVertices == 4)
                        {
                            var (isRect, w, h, ang) = TryRectInfo(pl);
                            if (isRect)
                            {
                                angle = ang;
                                double ratio = Math.Max(w, h) / Math.Max(1e-9, Math.Min(w, h));
                                if (IsSheetRatio(ratio)) score += 3.0; // looks like a sheet
                                score += 0.7; // clean rectangle bonus
        
                                // If attribute defs are inside the extents, bump score
                                if (attDefs.Count > 0)
                                {
                                    int inside = 0;
                                    foreach (var a in attDefs)
                                    {
                                        if (PointInExtents2D(a.Pos, ext.Value)) inside++;
                                    }
                                    // modest bump based on count
                                    score += Math.Min(2.0, inside * 0.3);
                                    // bonus if tags look like TB attributes
                                    int tagHits = attDefs.Count(a => PointInExtents2D(a.Pos, ext.Value) && attrTags.Contains(a.Tag));
                                    score += Math.Min(2.0, tagHits * 0.5);
                                }
                            }
                        }
                        // Secondary: a huge axis-aligned rectangle composed of lines/polylines
                        else if (ent is Polyline pl2 && pl2.Closed)
                        {
                            // Fallback on extents and size if not a clean 4-vertex rectangle
                            var v = ext.Value.MaxPoint - ext.Value.MinPoint;
                            double w = Math.Abs(v.X), h = Math.Abs(v.Y);
                            if (w > 0 && h > 0)
                            {
                                double ratio = Math.Max(w, h) / Math.Min(w, h);
                                if (IsSheetRatio(ratio)) score += 1.2;
                            }
                        }
        
                        // Size bias (prefer larger areas to avoid logos)
                        var s = ext.Value.MaxPoint - ext.Value.MinPoint;
                        double area = Math.Abs(s.X * s.Y);
                        if (area > 1) score += Math.Log10(area);
        
                        if (score >= 2.8)
                        {
                            candidates.Add((ent, ext.Value, score, angle));
                        }
                    }
        
                    // NEW: Detect rectangles composed of four Line segments (common border style)
                    var lines = new List<(Line L, Point2d P0, Point2d P1, Vector2d V, double Len, string Layer)>();
                    foreach (ObjectId id in ms)
                    {
                        if (!id.IsValid) continue;
                        if (tr.GetObject(id, OpenMode.ForRead, false) is Line ln)
                        {
                            var p0 = new Point2d(ln.StartPoint.X, ln.StartPoint.Y);
                            var p1 = new Point2d(ln.EndPoint.X, ln.EndPoint.Y);
                            var v = p1 - p0;
                            double len = v.Length;
                            if (len > 1e-6)
                            {
                                lines.Add((ln, p0, p1, v / len, len, ln.Layer));
                            }
                        }
                    }
        
                    if (lines.Count > 0)
                    {
                        // Prefer likely border layers and longer segments
                        var hinted = lines.Where(l => layerTokens.Any(t => l.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0)).ToList();
                        var poolSet = new HashSet<ObjectId>(hinted.Select(h => h.L.ObjectId));
                        var pool = new List<(Line L, Point2d P0, Point2d P1, Vector2d V, double Len, string Layer)>(hinted);
                        foreach (var x in lines.OrderByDescending(x => x.Len))
                        {
                            if (poolSet.Count >= 120) break; // cap
                            if (poolSet.Add(x.L.ObjectId)) pool.Add(x);
                        }
        
                        // Group by direction (parallel bins ~0.5 deg)
                        double deg = Math.PI / 180.0;
                        int totalBins = (int)Math.Round(Math.PI / (0.5 * deg)); // ~360
                        int Bin(double ang)
                        {
                            // parallel angle in [0,pi)
                            double a = ang;
                            double aPar = a % Math.PI; if (aPar < 0) aPar += Math.PI;
                            return (int)Math.Round(aPar / (0.5 * deg));
                        }
        
                        var groups = new Dictionary<int, List<int>>();
                        var angles = new List<double>();
                        for (int i = 0; i < pool.Count; i++)
                        {
                            double a = Math.Atan2(pool[i].V.Y, pool[i].V.X);
                            angles.Add(a);
                            int b = Bin(a);
                            if (!groups.TryGetValue(b, out var list)) groups[b] = list = new List<int>();
                            list.Add(i);
                        }
        
                        // helper for segment intersection
                        bool SegIntersect(Point2d a0, Point2d a1, Point2d b0, Point2d b1, out Point2d ip)
                        {
                            ip = default;
                            var r = a1 - a0; var s = b1 - b0;
                            double rxs = r.X * s.Y - r.Y * s.X;
                            double qpxr = (b0.X - a0.X) * r.Y - (b0.Y - a0.Y) * r.X;
                            double EPS = 1e-7;
                            if (Math.Abs(rxs) < EPS) return false; // parallel or colinear; skip
                            double t = ((b0.X - a0.X) * s.Y - (b0.Y - a0.Y) * s.X) / rxs;
                            double u = qpxr / rxs;
                            if (t < -1e-6 || t > 1 + 1e-6 || u < -1e-6 || u > 1 + 1e-6) return false;
                            ip = new Point2d(a0.X + t * r.X, a0.Y + t * r.Y);
                            return true;
                        }
        
                        // Try rectangle assembly from two parallel lines in A and two in B (perpendicular to A)
                        foreach (var kvA in groups)
                        {
                            // find perpendicular bins around +90 deg (+/- 1 bin)
                            int bins90 = (int)Math.Round(90.0 / 0.5); // 180 bins
                            int perpKeyCenter = (kvA.Key + bins90) % totalBins;
                            if (perpKeyCenter < 0) perpKeyCenter += totalBins;
                            int k0 = perpKeyCenter - 1; if (k0 < 0) k0 += totalBins;
                            int k1 = perpKeyCenter;
                            int k2 = perpKeyCenter + 1; if (k2 >= totalBins) k2 -= totalBins;
                            var perpKeys = new int[] { k0, k1, k2 };
                            foreach (int keyB in perpKeys)
                            {
                                if (!groups.TryGetValue(keyB, out var idxB)) continue;
        
                                var idxA = kvA.Value.OrderByDescending(i => pool[i].Len).Take(12).ToArray();
                                var idxBBest = idxB.OrderByDescending(i => pool[i].Len).Take(12).ToArray();
        
                                for (int i1 = 0; i1 < idxA.Length; i1++)
                                for (int i2 = i1 + 1; i2 < idxA.Length; i2++)
                                {
                                    var A1 = pool[idxA[i1]]; var A2 = pool[idxA[i2]];
                                    // ensure distinct and reasonably spaced
                                    // Separation between two parallel lines: project delta onto unit normal of A1
                                    var sepDeltaA = A2.P0 - A1.P0;
                                    var nA = new Vector2d(-A1.V.Y, A1.V.X); // rotate 90° CCW to get normal
                                    double sepA = Math.Abs(sepDeltaA.DotProduct(nA)); // A1.V is unit; nA is unit too
                                    if (sepA < 1e-4) continue;
        
                                    for (int j1 = 0; j1 < idxBBest.Length; j1++)
                                    for (int j2 = j1 + 1; j2 < idxBBest.Length; j2++)
                                    {
                                        var B1 = pool[idxBBest[j1]]; var B2 = pool[idxBBest[j2]];
                                        var deltaB = B2.P0 - B1.P0;
                                        var nB = new Vector2d(-B1.V.Y, B1.V.X);
                                        double distB = Math.Abs(deltaB.DotProduct(nB));
                                        if (distB < 1e-4) continue;
        
                                        // Compute the four corners
                                        if (!SegIntersect(A1.P0, A1.P1, B1.P0, B1.P1, out var C00)) continue;
                                        if (!SegIntersect(A1.P0, A1.P1, B2.P0, B2.P1, out var C01)) continue;
                                        if (!SegIntersect(A2.P0, A2.P1, B1.P0, B1.P1, out var C10)) continue;
                                        if (!SegIntersect(A2.P0, A2.P1, B2.P0, B2.P1, out var C11)) continue;
        
                                        var u = C01 - C00; var v = C10 - C00;
                                        double wLen = u.Length; double hLen = v.Length;
                                        if (wLen < 1e-4 || hLen < 1e-4) continue;
                                        // Orthogonality check
                                        double dot = Math.Abs(u.X * v.Y - u.Y * v.X); // use area magnitude to avoid normalization
                                        double norm = wLen * hLen;
                                        if (norm <= 0) continue;
                                        double sinTheta = dot / norm; // ~sin between u and v
                                        if (Math.Abs(sinTheta - 1.0) > 0.02) continue; // ~within ~1.15 degrees of 90°
        
                                        // Opposite sides roughly equal
                                        double wOpp = (C11 - C10).Length; double hOpp = (C11 - C01).Length;
                                        if (Math.Abs(wLen - wOpp) > 0.01 * Math.Max(wLen, wOpp)) continue;
                                        if (Math.Abs(hLen - hOpp) > 0.01 * Math.Max(hLen, hOpp)) continue;
        
                                        // Build extents from four corners
                                        double minX = new[] { C00.X, C01.X, C10.X, C11.X }.Min();
                                        double minY = new[] { C00.Y, C01.Y, C10.Y, C11.Y }.Min();
                                        double maxX = new[] { C00.X, C01.X, C10.X, C11.X }.Max();
                                        double maxY = new[] { C00.Y, C01.Y, C10.Y, C11.Y }.Max();
                                        var ext = new Extents3d(new Point3d(minX, minY, 0), new Point3d(maxX, maxY, 0));
        
                                        // Score
                                        double angle = Math.Atan2(u.Y, u.X);
                                        double ratio = Math.Max(wLen, hLen) / Math.Min(wLen, hLen);
                                        double score = 0.0;
                                        if (IsSheetRatio(ratio)) score += 3.0;
                                        // size bias
                                        double area = wLen * hLen;
                                        if (area > 1) score += Math.Log10(area);
                                        // layer hint from contributing lines
                                        int hintHits = 0;
                                        if (layerTokens.Any(t => A1.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0)) hintHits++;
                                        if (layerTokens.Any(t => A2.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0)) hintHits++;
                                        if (layerTokens.Any(t => B1.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0)) hintHits++;
                                        if (layerTokens.Any(t => B2.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0)) hintHits++;
                                        score += 0.2 * hintHits;
                                        // attributes inside
                                        if (attDefs.Count > 0)
                                        {
                                            int inside = 0;
                                            foreach (var a in attDefs) if (PointInExtents2D(a.Pos, ext)) inside++;
                                            score += Math.Min(2.0, inside * 0.3);
                                            int tagHits = attDefs.Count(a => PointInExtents2D(a.Pos, ext) && attrTags.Contains(a.Tag));
                                            score += Math.Min(2.0, tagHits * 0.5);
                                        }
        
                                        if (score >= 3.0)
                                        {
                                            candidates.Add((null, ext, score, angle));
                                        }
                                    }
                                }
                            }
                        }
                    }
        
                    // If nothing obvious, build a candidate from ATTDEF cluster
                    if (candidates.Count == 0 && attDefs.Count >= 3)
                    {
                        double minX = double.PositiveInfinity, minY = double.PositiveInfinity;
                        double maxX = double.NegativeInfinity, maxY = double.NegativeInfinity;
                        foreach (var a in attDefs)
                        {
                            minX = Math.Min(minX, a.Pos.X); minY = Math.Min(minY, a.Pos.Y);
                            maxX = Math.Max(maxX, a.Pos.X); maxY = Math.Max(maxY, a.Pos.Y);
                        }
                        // Expand a bit to cover border
                        double dx = (maxX - minX) * 0.2;
                        double dy = (maxY - minY) * 0.2;
                        var ext = new Extents3d(new Point3d(minX - dx, minY - dy, 0), new Point3d(maxX + dx, maxY + dy, 0));
                        candidates.Add((null, ext, 2.9, 0.0));
                    }
        
                    if (candidates.Count == 0)
                    {
                        ed.WriteMessage("\nNo likely title block found in Model Space.");
                    }
                    else
                    {
                        var best = candidates.OrderByDescending(c => c.Score).First();
                        var center = new Point3d(
                            (best.Ext.MinPoint.X + best.Ext.MaxPoint.X) / 2.0,
                            (best.Ext.MinPoint.Y + best.Ext.MaxPoint.Y) / 2.0,
                            0);
                        var sz = best.Ext.MaxPoint - best.Ext.MinPoint;
                        ed.WriteMessage($"\nLikely Title Block: Center {center}, Size {Math.Abs(sz.X):0.###} x {Math.Abs(sz.Y):0.###}, Rotation {best.Angle * 180/Math.PI:0.##}°");
                    }
        
                    tr.Commit();
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nError while searching for title block: {ex.Message}");
            }
        }
    }
}
```
===== END FindTitleBlockCommand.cs =====

===== BEGIN KeepOnlyTitleBlockCommand.cs =====
```csharp
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using Autodesk.AutoCAD.GraphicsSystem;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AutoCADCleanupTool
{
    public partial class CleanupCommands
    {
        // Find the titleblock region, preselect it and everything inside, then erase everything else in Model Space
        [CommandMethod("KEEPONLYTITLEBLOCKMS", CommandFlags.Modal)]
        public static void KeepOnlyTitleBlockInModelSpace()
        {
            Document doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            Database db = doc.Database;
            Editor ed = doc.Editor;

            try
            {
                var modelId = SymbolUtilityServices.GetBlockModelSpaceId(db);
                if (db.CurrentSpaceId != modelId)
                {
                    try { ed.SwitchToModelSpace(); } catch { try { Application.SetSystemVariable("TILEMODE", 1); } catch { } }
                }
            }
            catch { }

            string[] layerTokens = { "TITLE", "TBLK", "BORDER", "SHEET", "FRAME" };
            var attrTags = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "SHEET", "SHEETNO", "SHEET_NO", "SHEETNUMBER", "DWG", "DWG_NO",
                "DRAWN", "CHECKED", "APPROVED", "PROJECT", "CLIENT", "SCALE", "DATE",
                "REV", "REVISION", "TITLE"
            };

            HashSet<ObjectId> keepIds = null;
            try
            {
                using (Transaction tr = db.TransactionManager.StartTransaction())
                {
                    BlockTable bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead);
                    BlockTableRecord ms = (BlockTableRecord)tr.GetObject(bt[BlockTableRecord.ModelSpace], OpenMode.ForRead);

                    // Collect ATTDEF points for scoring
                    var attDefs = new List<(Point3d Pos, string Tag)>();
                    foreach (ObjectId id in ms)
                    {
                        if (!id.IsValid) continue;
                        DBObject dbo = tr.GetObject(id, OpenMode.ForRead, false);
                        if (dbo is AttributeDefinition ad && !ad.Invisible)
                            attDefs.Add((ad.Position, ad.Tag));
                    }

                    // Candidate container
                    var candidates = new List<(Extents3d Ext, double Score, double Angle, Point3d[] Poly, ObjectId[] Boundary)>();

                    // 1) Clean 4-vertex closed polylines
                    foreach (ObjectId id in ms)
                    {
                        if (!id.IsValid) continue;
                        if (!(tr.GetObject(id, OpenMode.ForRead, false) is Entity ent)) continue;

                        var ext = TryGetExtents(ent);
                        if (ext == null) continue;
                        double score = 0.0; double angle = 0.0;

                        if (layerTokens.Any(t => ent.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0))
                            score += 0.8;

                        if (ent is Polyline pl && pl.Closed && pl.NumberOfVertices == 4)
                        {
                            var (ok, w, h, ang) = TryRectInfo(pl);
                            if (!ok) continue;
                            angle = ang;
                            double ratio = Math.Max(w, h) / Math.Max(1e-9, Math.Min(w, h));
                            if (IsSheetRatio(ratio)) score += 3.0;
                            score += 0.7;

                            if (attDefs.Count > 0)
                            {
                                int inside = 0;
                                foreach (var a in attDefs) if (PointInExtents2D(a.Pos, ext.Value)) inside++;
                                score += Math.Min(2.0, inside * 0.3);
                                int tagHits = attDefs.Count(a => PointInExtents2D(a.Pos, ext.Value) && attrTags.Contains(a.Tag));
                                score += Math.Min(2.0, tagHits * 0.5);
                            }

                            // Build polygon from polyline vertices
                            var pts = new Point3d[4];
                            for (int i = 0; i < 4; i++)
                            {
                                var p2 = pl.GetPoint2dAt(i);
                                pts[i] = new Point3d(p2.X, p2.Y, 0);
                            }

                            // size bias
                            var s = ext.Value.MaxPoint - ext.Value.MinPoint;
                            double area = Math.Abs(s.X * s.Y);
                            if (area > 1) score += Math.Log10(area);

                            candidates.Add((ext.Value, score, angle, pts, new[] { ent.ObjectId }));
                        }
                    }

                    // 2) Rectangles made of four Lines
                    var lines = new List<(Line L, Point2d P0, Point2d P1, Vector2d V, double Len, string Layer)>();
                    foreach (ObjectId id in ms)
                    {
                        if (!id.IsValid) continue;
                        if (tr.GetObject(id, OpenMode.ForRead, false) is Line ln)
                        {
                            var p0 = new Point2d(ln.StartPoint.X, ln.StartPoint.Y);
                            var p1 = new Point2d(ln.EndPoint.X, ln.EndPoint.Y);
                            var v = p1 - p0;
                            double len = v.Length;
                            if (len > 1e-6) lines.Add((ln, p0, p1, v / len, len, ln.Layer));
                        }
                    }
                    if (lines.Count >= 4)
                    {
                        var hinted = lines.Where(l => layerTokens.Any(t => l.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0)).ToList();
                        var poolSet = new HashSet<ObjectId>(hinted.Select(h => h.L.ObjectId));
                        var pool = new List<(Line L, Point2d P0, Point2d P1, Vector2d V, double Len, string Layer)>(hinted);
                        foreach (var x in lines.OrderByDescending(x => x.Len))
                        {
                            if (poolSet.Count >= 120) break;
                            if (poolSet.Add(x.L.ObjectId)) pool.Add(x);
                        }

                        double deg = Math.PI / 180.0;
                        int totalBins = (int)Math.Round(Math.PI / (0.5 * deg));
                        int Bin(double ang)
                        {
                            double aPar = ang % Math.PI; if (aPar < 0) aPar += Math.PI;
                            return (int)Math.Round(aPar / (0.5 * deg));
                        }

                        var groups = new Dictionary<int, List<int>>();
                        for (int i = 0; i < pool.Count; i++)
                        {
                            int b = Bin(Math.Atan2(pool[i].V.Y, pool[i].V.X));
                            if (!groups.TryGetValue(b, out var list)) groups[b] = list = new List<int>();
                            list.Add(i);
                        }

                        bool SegIntersect(Point2d a0, Point2d a1, Point2d b0, Point2d b1, out Point2d ip)
                        {
                            ip = default;
                            var r = a1 - a0; var s = b1 - b0;
                            double rxs = r.X * s.Y - r.Y * s.X;
                            var qp = b0 - a0;
                            double qpxr = qp.X * r.Y - qp.Y * r.X;
                            double EPS = 1e-9;
                            if (Math.Abs(rxs) < EPS) return false;
                            double t = (qp.X * s.Y - qp.Y * s.X) / rxs;
                            double u = qpxr / rxs;
                            if (t < -1e-6 || t > 1 + 1e-6 || u < -1e-6 || u > 1 + 1e-6) return false;
                            ip = a0 + t * r;
                            return true;
                        }

                        foreach (var kvA in groups)
                        {
                            int bins90 = (int)Math.Round(90.0 / 0.5);
                            int perpKeyCenter = (kvA.Key + bins90) % totalBins;
                            var perpKeys = new int[] { (perpKeyCenter - 1 + totalBins) % totalBins, perpKeyCenter, (perpKeyCenter + 1) % totalBins };

                            if (!kvA.Value.Any()) continue;
                            var idxA = kvA.Value.OrderByDescending(i => pool[i].Len).Take(12).ToArray();

                            foreach (int keyB in perpKeys)
                            {
                                if (!groups.TryGetValue(keyB, out var idxB)) continue;
                                var idxBBest = idxB.OrderByDescending(i => pool[i].Len).Take(12).ToArray();

                                for (int i1 = 0; i1 < idxA.Length; i1++)
                                    for (int i2 = i1 + 1; i2 < idxA.Length; i2++)
                                    {
                                        var A1 = pool[idxA[i1]]; var A2 = pool[idxA[i2]];
                                        var nA = new Vector2d(-A1.V.Y, A1.V.X);
                                        if (Math.Abs(A1.V.DotProduct(A2.V)) < 0.98) continue; // Ensure lines are parallel

                                        for (int j1 = 0; j1 < idxBBest.Length; j1++)
                                            for (int j2 = j1 + 1; j2 < idxBBest.Length; j2++)
                                            {
                                                var B1 = pool[idxBBest[j1]]; var B2 = pool[idxBBest[j2]];
                                                if (Math.Abs(B1.V.DotProduct(B2.V)) < 0.98) continue; // Ensure lines are parallel

                                                if (!SegIntersect(A1.P0, A1.P1, B1.P0, B1.P1, out var C00)) continue;
                                                if (!SegIntersect(A1.P0, A1.P1, B2.P0, B2.P1, out var C01)) continue;
                                                if (!SegIntersect(A2.P0, A2.P1, B1.P0, B1.P1, out var C10)) continue;
                                                if (!SegIntersect(A2.P0, A2.P1, B2.P0, B2.P1, out var C11)) continue;

                                                var u = C01 - C00; var v = C10 - C00;
                                                double wLen = u.Length, hLen = v.Length; if (wLen < 1e-4 || hLen < 1e-4) continue;
                                                double dotArea = Math.Abs(u.X * v.Y - u.Y * v.X);
                                                double norm = wLen * hLen; if (norm <= 0) continue;
                                                double sinTheta = dotArea / norm; if (Math.Abs(sinTheta - 1.0) > 0.02) continue;
                                                double wOpp = (C11 - C10).Length, hOpp = (C11 - C01).Length;
                                                if (Math.Abs(wLen - wOpp) > 0.015 * Math.Max(wLen, wOpp)) continue;
                                                if (Math.Abs(hLen - hOpp) > 0.015 * Math.Max(hLen, hOpp)) continue;

                                                var ext = new Extents3d();
                                                ext.AddPoint(new Point3d(C00.X, C00.Y, 0));
                                                ext.AddPoint(new Point3d(C01.X, C01.Y, 0));
                                                ext.AddPoint(new Point3d(C10.X, C10.Y, 0));
                                                ext.AddPoint(new Point3d(C11.X, C11.Y, 0));

                                                double angle = Math.Atan2(u.Y, u.X);
                                                double ratio = Math.Max(wLen, hLen) / Math.Min(wLen, hLen);
                                                double score = 0.0; if (IsSheetRatio(ratio)) score += 3.0;
                                                double area = wLen * hLen; if (area > 1) score += Math.Log10(area);
                                                int hintHits = (new[] { A1, A2, B1, B2 }).Count(l => layerTokens.Any(t => l.Layer.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0));
                                                score += 0.2 * hintHits;
                                                if (attDefs.Count > 0)
                                                {
                                                    int inside = attDefs.Count(a => PointInExtents2D(a.Pos, ext));
                                                    score += Math.Min(2.0, inside * 0.3);
                                                    int tagHits = attDefs.Count(a => PointInExtents2D(a.Pos, ext) && attrTags.Contains(a.Tag));
                                                    score += Math.Min(2.0, tagHits * 0.5);
                                                }
                                                if (score >= 3.0)
                                                {
                                                    var poly = new[]
                                                    {
                                                        new Point3d(C00.X, C00.Y, 0), new Point3d(C01.X, C01.Y, 0),
                                                        new Point3d(C11.X, C11.Y, 0), new Point3d(C10.X, C10.Y, 0)
                                                    };
                                                    var boundary = new[] { A1.L.ObjectId, A2.L.ObjectId, B1.L.ObjectId, B2.L.ObjectId };
                                                    candidates.Add((ext, score, angle, poly, boundary));
                                                }
                                            }
                                    }
                            }
                        }
                    }

                    // 3) Fallback to ATTDEF cluster extents
                    if (candidates.Count == 0 && attDefs.Count >= 3)
                    {
                        var extentsBuilder = new Extents3d();
                        attDefs.ForEach(a => extentsBuilder.AddPoint(a.Pos));
                        var ext = extentsBuilder;

                        double minWidth = 10.0; // Minimum reasonable width
                        double minHeight = 7.5; // Minimum reasonable height
                        double dx = Math.Max((ext.MaxPoint.X - ext.MinPoint.X) * 0.25, minWidth);
                        double dy = Math.Max((ext.MaxPoint.Y - ext.MinPoint.Y) * 0.25, minHeight);
                        ext = new Extents3d(new Point3d(ext.MinPoint.X - dx, ext.MinPoint.Y - dy, 0), new Point3d(ext.MaxPoint.X + dx, ext.MaxPoint.Y + dy, 0));
                        var poly = new[]
                        {
                            new Point3d(ext.MinPoint.X, ext.MinPoint.Y, 0),
                            new Point3d(ext.MaxPoint.X, ext.MinPoint.Y, 0),
                            new Point3d(ext.MaxPoint.X, ext.MaxPoint.Y, 0),
                            new Point3d(ext.MinPoint.X, ext.MaxPoint.Y, 0)
                        };
                        candidates.Add((ext, 2.9, 0.0, poly, Array.Empty<ObjectId>()));
                    }

                    if (candidates.Count == 0)
                    {
                        ed.WriteMessage("\nNo likely title block found in Model Space.");
                        tr.Commit();
                        return;
                    }

                    var best = candidates.OrderByDescending(c => c.Score).First();

                    // *** FIX: Use ed.CurrentUserCoordinateSystem which is a Matrix3d and has .Inverse() ***
                    var ucs = ed.CurrentUserCoordinateSystem;
                    var wcs_poly = best.Poly.Select(p => p.TransformBy(ucs.Inverse())).ToArray();

                    var expandedPoly = ExpandTitleBlockPolygon(wcs_poly);
                    ZoomToTitleBlock(ed, expandedPoly ?? wcs_poly);

                    // Select objects strictly inside the found polygon
                    var polyColl = new Point3dCollection(expandedPoly ?? best.Poly);
                    var selRes = ed.SelectCrossingPolygon(polyColl);
                    if (selRes.Status != PromptStatus.OK)
                    {
                        ed.WriteMessage("\nNothing found inside the detected titleblock region.");
                        tr.Commit();
                        return;
                    }

                    keepIds = new HashSet<ObjectId>(selRes.Value.GetObjectIds());
                    // Ensure the border entities themselves are also kept
                    foreach (var bid in best.Boundary) if (!bid.IsNull) keepIds.Add(bid);

                    tr.Commit();
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nError in KEEPONLYTITLEBLOCKMS: {ex.Message}\n{ex.StackTrace}");
                return;
            }

            if (keepIds == null || keepIds.Count == 0)
            {
                return;
            }

            try
            {
                var modelSpaceId = SymbolUtilityServices.GetBlockModelSpaceId(db);
                EraseEntitiesExcept(db, ed, modelSpaceId, keepIds);
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nFailed to prune model space: {ex.Message}");
            }
        }

        private static Extents3d ExpandExtents(Extents3d ext, double fraction)
        {
            double width = Math.Abs(ext.MaxPoint.X - ext.MinPoint.X);
            double height = Math.Abs(ext.MaxPoint.Y - ext.MinPoint.Y);
            double dx = Math.Max(width * fraction, 1e-4);
            double dy = Math.Max(height * fraction, 1e-4);

            return new Extents3d(
                new Point3d(ext.MinPoint.X - dx, ext.MinPoint.Y - dy, ext.MinPoint.Z),
                new Point3d(ext.MaxPoint.X + dx, ext.MaxPoint.Y + dy, ext.MaxPoint.Z));
        }

        public static void ZoomToTitleBlock(Editor ed, Point3d[] poly)
        {
            if (ed == null || poly == null || poly.Length < 3) return;

            try
            {
                var ext = new Extents3d(poly[0], poly[0]);
                for (int i = 1; i < poly.Length; i++)
                {
                    ext.AddPoint(poly[i]);
                }

                double width = Math.Abs(ext.MaxPoint.X - ext.MinPoint.X);
                double height = Math.Abs(ext.MaxPoint.Y - ext.MinPoint.Y);

                if (width < 1e-4 || height < 1e-4)
                {
                    ed.WriteMessage("\nDetected title block area is too small, skipping zoom.");
                    return;
                }

                double margin = Math.Max(width, height) * 0.05;

                Point3d pMin = new Point3d(ext.MinPoint.X - margin, ext.MinPoint.Y - margin, ext.MinPoint.Z);
                Point3d pMax = new Point3d(ext.MaxPoint.X + margin, ext.MaxPoint.Y + margin, ext.MaxPoint.Z);

                Zoom(pMin, pMax, Point3d.Origin, 1.0);
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nError during zoom: {ex.Message}");
            }
        }

        public static void Zoom(Point3d pMin, Point3d pMax, Point3d pCenter, double dFactor)
        {
            Document acDoc = Application.DocumentManager.MdiActiveDocument;
            if (acDoc == null) return;
            Database acCurDb = acDoc.Database;
            Editor ed = acDoc.Editor;

            using (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())
            {
                using (ViewTableRecord acView = ed.GetCurrentView())
                {
                    Point2d pNewCentPt;
                    double dWidth, dHeight;

                    Matrix3d matWCS2DCS = Matrix3d.PlaneToWorld(acView.ViewDirection);
                    matWCS2DCS = Matrix3d.Displacement(acView.Target - Point3d.Origin) * matWCS2DCS;
                    matWCS2DCS = Matrix3d.Rotation(-acView.ViewTwist, acView.ViewDirection, acView.Target) * matWCS2DCS;
                    matWCS2DCS = matWCS2DCS.Inverse();

                    if (pCenter.DistanceTo(Point3d.Origin) != 0)
                    {
                        pNewCentPt = new Point2d(pCenter.X, pCenter.Y);
                        dWidth = acView.Width;
                        dHeight = acView.Height;
                    }
                    else
                    {
                        var extents = new Extents3d(pMin, pMax);
                        extents.TransformBy(matWCS2DCS);
                        dWidth = extents.MaxPoint.X - extents.MinPoint.X;
                        dHeight = extents.MaxPoint.Y - extents.MinPoint.Y;
                        pNewCentPt = new Point2d((extents.MinPoint.X + extents.MaxPoint.X) / 2.0, (extents.MinPoint.Y + extents.MaxPoint.Y) / 2.0);
                    }

                    double dViewRatio = acView.Width / acView.Height;
                    if (dWidth > (dHeight * dViewRatio))
                    {
                        dHeight = dWidth / dViewRatio;
                    }

                    acView.CenterPoint = pNewCentPt;
                    acView.Width = dWidth * dFactor;
                    acView.Height = dHeight * dFactor;

                    ed.SetCurrentView(acView);
                }
                acTrans.Commit();
            }
        }

        private static Point3d[] ExpandTitleBlockPolygon(Point3d[] poly)
        {
            if (poly == null || poly.Length != 4)
            {
                return poly;
            }

            var center = new Point3d(
                (poly[0].X + poly[1].X + poly[2].X + poly[3].X) / 4.0,
                (poly[0].Y + poly[1].Y + poly[2].Y + poly[3].Y) / 4.0,
                0
            );

            // *** FIX: Changed GetDistanceTo to DistanceTo ***
            double side1 = poly[0].DistanceTo(poly[1]);
            double side2 = poly[0].DistanceTo(poly[3]);

            double margin = Math.Max(0.01, Math.Min(side1, side2) * 0.005);

            var expandedPoly = new Point3d[4];
            for (int i = 0; i < 4; i++)
            {
                var vecFromCenter = poly[i] - center;
                if (vecFromCenter.Length < 1e-6) return poly;
                expandedPoly[i] = poly[i] + vecFromCenter.GetNormal() * margin;
            }

            return expandedPoly;
        }
    }
}
```
===== END KeepOnlyTitleBlockCommand.cs =====

===== BEGIN SimplerCommands.cs =====
```csharp
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using System.Collections.Generic;
using System;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.IO;
using System.Globalization;

namespace AutoCADCleanupTool
{
    public partial class SimplerCommands
    {
        // Win32 helpers to auto-dismiss the "OLE Text Size" dialog
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);

        [DllImport("user32.dll")] private static extern bool SetForegroundWindow(IntPtr hWnd);
        [DllImport("user32.dll")] private static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

        private const uint BM_CLICK = 0x00F5;
        private const uint WM_COMMAND = 0x0111;
        private const int IDOK = 1;

        private static void StartOleTextSizeDialogCloser(double seconds = 120)
        {
            Task.Run(() =>
            {
                var until = DateTime.UtcNow.AddSeconds(seconds);
                while (DateTime.UtcNow < until)
                {
                    try
                    {
                        // Common dialog class is #32770; exact title is "OLE Text Size"
                        IntPtr dlg = FindWindow("#32770", "OLE Text Size");
                        if (dlg != IntPtr.Zero)
                        {
                            // Prefer clicking OK button directly
                            IntPtr ok = FindWindowEx(dlg, IntPtr.Zero, "Button", "OK");
                            if (ok != IntPtr.Zero)
                            {
                                SendMessage(ok, BM_CLICK, IntPtr.Zero, IntPtr.Zero);
                            }
                            else
                            {
                                // Fallbacks: try IDOK, then Enter
                                SendMessage(dlg, WM_COMMAND, (IntPtr)IDOK, IntPtr.Zero);
                                SetForegroundWindow(dlg);
                                System.Windows.Forms.SendKeys.SendWait("{ENTER}");
                            }
                            return;
                        }
                    }
                    catch { /* ignore and retry */ }
                    Thread.Sleep(150);
                }
            });
        }

        // Data and helpers to embed OLE images over existing raster image references
        private class ImagePlacement
        {
            public string Path;
            public Autodesk.AutoCAD.Geometry.Point3d Pos;
            public Autodesk.AutoCAD.Geometry.Vector3d U;
            public Autodesk.AutoCAD.Geometry.Vector3d V;
            public ObjectId ImageId;
        }

        private static readonly Queue<ImagePlacement> _pending = new Queue<ImagePlacement>();
        private static ObjectId _lastPastedOle = ObjectId.Null;
        private static bool _handlersAttached = false;
        private static dynamic _pptAppShared = null;
        private static dynamic _pptPresentationShared = null;
        // Save/restore current layer while embedding
        private static ObjectId _savedClayer = ObjectId.Null;
        // Track candidate image definitions for purge after embedding
        private static readonly HashSet<ObjectId> _imageDefsToPurge = new HashSet<ObjectId>();
        // Chain flag: when true, run FINALIZE after EMBEDFROMXREFS completes
        private static bool _chainFinalizeAfterEmbed = false;
        // Track state for queuing paste insertion points
        private static ImagePlacement _activePlacement = null;
        private static Document _activePasteDocument = null;
        private static bool _waitingForPasteStart = false;
        private static bool _pastePointHandlerAttached = false;

        private static bool EnsurePowerPoint(Editor ed)
        {
            try
            {
                // Validate existing COM objects if present
                if (_pptAppShared != null)
                {
                    try
                    {
                        var presentations = _pptAppShared.Presentations;
                        try { _pptAppShared.Visible = true; } catch { }

                        if (_pptPresentationShared != null)
                        {
                            try
                            {
                                var slides = _pptPresentationShared.Slides;
                                int count = 0;
                                try { count = slides.Count; } catch { count = 0; }
                                if (count < 1)
                                {
                                    // Ensure a blank slide exists (ppLayoutBlank = 12)
                                    _pptPresentationShared.Slides.Add(1, 12);
                                }
                                return true;
                            }
                            catch
                            {
                                // Presentation reference is stale; create a new presentation
                                _pptPresentationShared = presentations.Add();
                                _pptPresentationShared.Slides.Add(1, 12);
                                return true;
                            }
                        }
                        else
                        {
                            _pptPresentationShared = presentations.Add();
                            _pptPresentationShared.Slides.Add(1, 12);
                            return true;
                        }
                    }
                    catch
                    {
                        // App reference is stale; release and recreate below
                        try { Marshal.FinalReleaseComObject(_pptAppShared); } catch { }
                        _pptAppShared = null;
                        _pptPresentationShared = null;
                    }
                }

                // Create new instance if we get here
                Type pptType = Type.GetTypeFromProgID("PowerPoint.Application");
                if (pptType == null)
                {
                    ed.WriteMessage("\nPowerPoint is not installed (COM ProgID not found).");
                    return false;
                }
                _pptAppShared = Activator.CreateInstance(pptType);
                try { _pptAppShared.Visible = true; } catch { }
                var pres = _pptAppShared.Presentations;
                _pptPresentationShared = pres.Add();
                _pptPresentationShared.Slides.Add(1, 12); // ppLayoutBlank
                return true;
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nFailed to start or access PowerPoint: {ex.Message}");
                try { if (_pptAppShared != null) Marshal.FinalReleaseComObject(_pptAppShared); } catch { }
                _pptAppShared = null;
                _pptPresentationShared = null;
                return false;
            }
        }

        // Close and release the shared PowerPoint COM objects without saving
        private static void ClosePowerPoint(Editor ed = null)
        {
            try
            {
                if (_pptPresentationShared != null)
                {
                    try { _pptPresentationShared.Saved = -1; } catch { }
                    try { _pptPresentationShared.Close(); } catch { }
                    try { Marshal.FinalReleaseComObject(_pptPresentationShared); } catch { }
                    _pptPresentationShared = null;
                }
                if (_pptAppShared != null)
                {
                    try { _pptAppShared.Quit(); } catch { }
                    try { Marshal.FinalReleaseComObject(_pptAppShared); } catch { }
                    _pptAppShared = null;
                }
            }
            catch (System.Exception ex)
            {
                try { ed?.WriteMessage($"\nWarning: failed to close PowerPoint: {ex.Message}"); } catch { }
                _pptPresentationShared = null;
                _pptAppShared = null;
            }
        }

        private static bool PrepareClipboardWithImageShared(string path, Editor ed)
        {
            try
            {
                if (!EnsurePowerPoint(ed)) return false;
                dynamic slide = _pptPresentationShared.Slides[1]; // 1-based
                var shapes = slide.Shapes;
                // Clear previous shapes
                for (int i = shapes.Count; i >= 1; i--)
                {
                    try { shapes[i].Delete(); } catch { }
                }
                dynamic pic = shapes.AddPicture(path, false, true, 10, 10);
                pic.Copy();
                return true;
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nFailed to prepare clipboard for '{path}': {ex.Message}");
                return false;
            }
        }

        // Resolve a possibly relative image path against the DWG folder and AutoCAD search paths
        private static string ResolveImagePath(Database db, string rawPath)
        {
            if (string.IsNullOrWhiteSpace(rawPath)) return null;

            string p = rawPath.Trim().Trim('"').Replace('/', '\\');

            // If it already exists as-is
            if (Path.IsPathRooted(p) && File.Exists(p))
                return p;

            // Try base DWG folder if available
            try
            {
                string dbFile = db?.Filename;
                if (!string.IsNullOrWhiteSpace(dbFile))
                {
                    string baseDir = Path.GetDirectoryName(dbFile);
                    if (!string.IsNullOrWhiteSpace(baseDir))
                    {
                        // Handle drive-less rooted path like "\folder\file.png" by injecting drive from DWG
                        if (Path.IsPathRooted(p) && p.StartsWith("\\") && !p.StartsWith("\\\\"))
                        {
                            string drive = Path.GetPathRoot(baseDir); // e.g., C:\
                            string combined = Path.Combine(drive ?? string.Empty, p.TrimStart('\\'));
                            string full = Path.GetFullPath(combined);
                            if (File.Exists(full)) return full;
                        }

                        // Plain relative
                        string candidate = Path.GetFullPath(Path.Combine(baseDir, p));
                        if (File.Exists(candidate))
                            return candidate;
                    }
                }
            }
            catch { }

            // Fall back to AutoCAD search paths (support paths, etc.) using only the file name
            try
            {
                string nameOnly = Path.GetFileName(p);
                if (!string.IsNullOrEmpty(nameOnly))
                {
                    string found = HostApplicationServices.Current.FindFile(nameOnly, db, FindFileHint.Default);
                    if (!string.IsNullOrWhiteSpace(found) && File.Exists(found))
                        return found;
                }
            }
            catch { }

            return null;
        }

        private static void AttachHandlers(Database db, Document doc)
        {
            if (_handlersAttached) return;
            db.ObjectAppended += Db_ObjectAppended;
            doc.CommandWillStart += Doc_CommandWillStart;
            doc.CommandEnded += Doc_CommandEnded;
            _handlersAttached = true;
        }

        private static void DetachHandlers(Database db, Document doc)
        {
            if (!_handlersAttached) return;
            try { db.ObjectAppended -= Db_ObjectAppended; } catch { }
            try { doc.CommandWillStart -= Doc_CommandWillStart; } catch { }
            try { doc.CommandEnded -= Doc_CommandEnded; } catch { }
            if (_pastePointHandlerAttached)
            {
                try { Autodesk.AutoCAD.ApplicationServices.Application.Idle -= Application_OnIdleSendPastePoint; } catch { }
                _pastePointHandlerAttached = false;
            }
            _activePlacement = null;
            _activePasteDocument = null;
            _waitingForPasteStart = false;
            _handlersAttached = false;
        }

        // Remove unused image definitions whose RasterImage references were replaced by OLEs
        private static void PurgeEmbeddedImageDefs(Database db, Editor ed)
        {
            if (_imageDefsToPurge.Count == 0) return;
            try
            {
                var candidates = new HashSet<ObjectId>();
                foreach (var defId in _imageDefsToPurge)
                {
                    try
                    {
                        if (!defId.IsNull && defId.Database == db)
                        {
                            candidates.Add(defId);
                        }
                    }
                    catch
                    {
                        // Ignore ids from prior drawings or disposed databases
                    }
                }

                if (candidates.Count == 0)
                {
                    return;
                }

                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var named = (DBDictionary)tr.GetObject(db.NamedObjectsDictionaryId, OpenMode.ForRead);
                    if (!named.Contains("ACAD_IMAGE_DICT"))
                    {
                        tr.Commit();
                        return;
                    }

                    var imageDict = (DBDictionary)tr.GetObject(named.GetAt("ACAD_IMAGE_DICT"), OpenMode.ForWrite);
                    var keysById = new Dictionary<ObjectId, string>();
                    foreach (DBDictionaryEntry entry in imageDict)
                    {
                        if (candidates.Contains(entry.Value))
                        {
                            keysById[entry.Value] = entry.Key;
                        }
                    }

                    if (keysById.Count == 0)
                    {
                        tr.Commit();
                        return;
                    }

                    var imagesByDef = new Dictionary<ObjectId, List<ObjectId>>();
                    foreach (var id in keysById.Keys)
                    {
                        imagesByDef[id] = new List<ObjectId>();
                    }

                    var bt = (BlockTable)tr.GetObject(db.BlockTableId, OpenMode.ForRead);
                    foreach (ObjectId btrId in bt)
                    {
                        var btr = (BlockTableRecord)tr.GetObject(btrId, OpenMode.ForRead);
                        foreach (ObjectId entId in btr)
                        {
                            if (entId.ObjectClass.DxfName != "IMAGE") continue;
                            var img = tr.GetObject(entId, OpenMode.ForRead) as RasterImage;
                            if (img == null || img.ImageDefId.IsNull) continue;
                            if (imagesByDef.TryGetValue(img.ImageDefId, out var list))
                            {
                                list.Add(entId);
                            }
                        }
                    }

                    int erasedImages = 0;
                    foreach (var kvp in imagesByDef)
                    {
                        foreach (var entId in kvp.Value)
                        {
                            try
                            {
                                var img = tr.GetObject(entId, OpenMode.ForWrite, false) as RasterImage;
                                if (img == null) continue;
                                var layer = (LayerTableRecord)tr.GetObject(img.LayerId, OpenMode.ForRead);
                                bool relock = false;
                                if (layer.IsLocked)
                                {
                                    layer.UpgradeOpen();
                                    layer.IsLocked = false;
                                    relock = true;
                                }
                                img.Erase();
                                if (relock)
                                {
                                    layer.IsLocked = true;
                                }
                                erasedImages++;
                            }
                            catch (System.Exception ex)
                            {
                                ed.WriteMessage($"\nFailed to erase leftover raster image {entId}: {ex.Message}");
                            }
                        }
                    }

                    int purged = 0;
                    foreach (var defId in keysById.Keys)
                    {
                        if (keysById.TryGetValue(defId, out var key) && !string.IsNullOrEmpty(key))
                        {
                            try
                            {
                                imageDict.Remove(key);
                            }
                            catch (System.Exception ex)
                            {
                                ed.WriteMessage($"\nFailed to remove image dictionary entry '{key}': {ex.Message}");
                            }
                        }

                        try
                        {
                            var defObj = tr.GetObject(defId, OpenMode.ForWrite, false);
                            if (defObj != null && !defObj.IsErased)
                            {
                                defObj.Erase();
                                purged++;
                            }
                        }
                        catch (System.Exception ex)
                        {
                            ed.WriteMessage($"\nFailed to erase image definition {defId}: {ex.Message}");
                        }
                    }

                    if (erasedImages > 0 || purged > 0)
                    {
                        ed.WriteMessage($"\nRemoved {erasedImages} leftover raster image(s) and purged {purged} image definition(s).");
                    }

                    tr.Commit();
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nFailed to purge image definitions: {ex.Message}");
            }
            finally
            {
                _imageDefsToPurge.Clear();
            }
        }

        private static void Db_ObjectAppended(object sender, ObjectEventArgs e)
        {
            try
            {
                if (e.DBObject is Ole2Frame)
                {
                    _lastPastedOle = e.DBObject.ObjectId;
                }
            }
            catch { }
        }


        private static void Doc_CommandWillStart(object sender, Autodesk.AutoCAD.ApplicationServices.CommandEventArgs e)
        {
            try
            {
                if (!string.Equals(e.GlobalCommandName, "PASTECLIP", StringComparison.OrdinalIgnoreCase)) return;
                if (!_waitingForPasteStart || _activePlacement == null) return;
                if (_pastePointHandlerAttached) return;

                if (_activePasteDocument == null)
                {
                    _activePasteDocument = Application.DocumentManager.MdiActiveDocument;
                }

                Autodesk.AutoCAD.ApplicationServices.Application.Idle += Application_OnIdleSendPastePoint;
                _pastePointHandlerAttached = true;
            }
            catch { }
        }

        private static void Application_OnIdleSendPastePoint(object sender, EventArgs e)
        {
            try
            {
                Autodesk.AutoCAD.ApplicationServices.Application.Idle -= Application_OnIdleSendPastePoint;
                _pastePointHandlerAttached = false;

                var doc = _activePasteDocument ?? Application.DocumentManager.MdiActiveDocument;
                var placement = _activePlacement;
                if (doc == null || placement == null)
                {
                    return;
                }

                string active = null;
                try { active = doc.CommandInProgress; } catch { }
                if (!string.Equals(active, "PASTECLIP", StringComparison.OrdinalIgnoreCase))
                {
                    return;
                }

                string x = placement.Pos.X.ToString("G17", CultureInfo.InvariantCulture);
                string y = placement.Pos.Y.ToString("G17", CultureInfo.InvariantCulture);

                doc.SendStringToExecute($"{x},{y}\n1\n0\n", true, false, false);
            }
            catch
            {
            }
            finally
            {
                _waitingForPasteStart = false;
            }
        }

        private static void Doc_CommandEnded(object sender, Autodesk.AutoCAD.ApplicationServices.CommandEventArgs e)
        {
            try
            {
                if (!string.Equals(e.GlobalCommandName, "PASTECLIP", StringComparison.OrdinalIgnoreCase)) return;

                var doc = Application.DocumentManager.MdiActiveDocument;
                if (doc == null) return;
                var db = doc.Database;
                var ed = doc.Editor;

                _waitingForPasteStart = false;
                if (_pastePointHandlerAttached)
                {
                    try { Autodesk.AutoCAD.ApplicationServices.Application.Idle -= Application_OnIdleSendPastePoint; } catch { }
                    _pastePointHandlerAttached = false;
                }

                if (_pending.Count == 0)
                {
                    _activePlacement = null;
                    _activePasteDocument = null;
                    _lastPastedOle = ObjectId.Null;
                    return;
                }

                if (_lastPastedOle.IsNull)
                {
                    _pending.Dequeue();
                    _activePlacement = null;
                    _activePasteDocument = null;
                    ed.WriteMessage("\nSkipping a raster image because no OLE object was created.");

                    if (_pending.Count > 0)
                    {
                        ProcessNextPaste(doc, ed);
                    }
                    else
                    {
                        FinishEmbeddingRun(doc, ed, db);
                    }
                    return;
                }

                var target = _pending.Dequeue();
                _activePlacement = null;
                _activePasteDocument = doc;

                using (var tr = db.TransactionManager.StartTransaction())
                {
                    var ole = tr.GetObject(_lastPastedOle, OpenMode.ForWrite) as Ole2Frame;
                    if (ole != null)
                    {
                        try
                        {
                            var ext = ole.GeometricExtents;
                            double oleW = Math.Max(1e-8, ext.MaxPoint.X - ext.MinPoint.X);
                            double oleH = Math.Max(1e-8, ext.MaxPoint.Y - ext.MinPoint.Y);

                            var srcOrigin = new Autodesk.AutoCAD.Geometry.Point3d(ext.MinPoint.X, ext.MinPoint.Y, ext.MinPoint.Z);
                            var srcX = new Autodesk.AutoCAD.Geometry.Vector3d(oleW, 0, 0);
                            var srcY = new Autodesk.AutoCAD.Geometry.Vector3d(0, oleH, 0);
                            var srcZ = Autodesk.AutoCAD.Geometry.Vector3d.ZAxis;

                            var destOrigin = target.Pos;
                            var destX = target.U;
                            var destY = target.V;
                            var destZ = destX.CrossProduct(destY);

                            var m = Autodesk.AutoCAD.Geometry.Matrix3d.AlignCoordinateSystem(
                                srcOrigin, srcX, srcY, srcZ,
                                destOrigin, destX, destY, destZ);

                            ole.TransformBy(m);

                            // Ensure pasted OLE is on layer "0"
                            try { ole.Layer = "0"; } catch { }
                        }
                        catch (System.Exception ex1)
                        {
                            ed.WriteMessage($"\nFailed to transform pasted OLE: {ex1.Message}");
                        }
                    }
                    // After placing the OLE where we want it, erase the original raster image entity
                    try
                    {
                        var imgEnt = tr.GetObject(target.ImageId, OpenMode.ForWrite, false) as RasterImage;
                        if (imgEnt != null)
                        {
                            try
                            {
                                if (!imgEnt.ImageDefId.IsNull)
                                    _imageDefsToPurge.Add(imgEnt.ImageDefId);
                            }
                            catch { }
                            // Unlock layer if needed
                            var layer = (LayerTableRecord)tr.GetObject(imgEnt.LayerId, OpenMode.ForRead);
                            bool relock = false;
                            if (layer.IsLocked)
                            {
                                layer.UpgradeOpen();
                                layer.IsLocked = false;
                                relock = true;
                            }
                            imgEnt.Erase();
                            if (relock)
                            {
                                layer.IsLocked = true;
                            }
                        }
                    }
                    catch (System.Exception exErase)
                    {
                        ed.WriteMessage($"\nWarning: failed to erase source raster image: {exErase.Message}");
                    }
                    tr.Commit();
                }

                _lastPastedOle = ObjectId.Null;

                if (_pending.Count > 0)
                {
                    ProcessNextPaste(doc, ed);
                }
                else
                {
                    FinishEmbeddingRun(doc, ed, db);
                }
            }
            catch { }
        }

        private static void FinishEmbeddingRun(Document doc, Editor ed, Database db)
        {
            ed.WriteMessage("\nCompleted embedding over all raster images.");
            DetachHandlers(db, doc);
            PurgeEmbeddedImageDefs(db, ed);
            ClosePowerPoint(ed);
            try { if (!_savedClayer.IsNull && db.Clayer != _savedClayer) db.Clayer = _savedClayer; } catch { }
            _savedClayer = ObjectId.Null;
            if (_chainFinalizeAfterEmbed)
            {
                _chainFinalizeAfterEmbed = false;
                doc.SendStringToExecute("_.FINALIZE ", true, false, false);
            }
        }

        private static void ProcessNextPaste(Document doc, Editor ed)
        {
            if (_pending.Count == 0) return;
            var target = _pending.Peek();

            if (!PrepareClipboardWithImageShared(target.Path, ed))
            {
                _pending.Dequeue();
                _activePlacement = null;

                if (_pending.Count > 0)
                {
                    ProcessNextPaste(doc, ed);
                }
                else
                {
                    FinishEmbeddingRun(doc, ed, doc.Database);
                }
                return;
            }

            StartOleTextSizeDialogCloser(120);

            _activePlacement = target;
            _activePasteDocument = doc;
            _waitingForPasteStart = true;

            if (_pastePointHandlerAttached)
            {
                try { Autodesk.AutoCAD.ApplicationServices.Application.Idle -= Application_OnIdleSendPastePoint; } catch { }
                _pastePointHandlerAttached = false;
            }
            doc.SendStringToExecute("_.PASTECLIP\n", true, false, false);
        }

    }
}
```
===== END SimplerCommands.cs =====

===== BEGIN ViewportToPolyline.cs =====
```csharp
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Geometry;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AutoCADCleanupTool
{
    public partial class CleanupCommands
    {
        [CommandMethod("VP2PL", CommandFlags.Modal)]
        public static void ViewportToPolyline_AllLayouts()
        {
            var doc = Application.DocumentManager.MdiActiveDocument;
            if (doc == null) return;
            var db = doc.Database;
            var ed = doc.Editor;

            try
            {
                using (doc.LockDocument())
                {
                    var modelPolys = new List<List<Point3d>>();

                    // ---- Enumerate ALL paper-space layouts via Layout Dictionary ----
                    using (var tr = db.TransactionManager.StartTransaction())
                    {
                        var layoutDict = (DBDictionary)tr.GetObject(db.LayoutDictionaryId, OpenMode.ForRead);

                        foreach (DBDictionaryEntry kv in layoutDict)
                        {
                            var layout = (Layout)tr.GetObject(kv.Value, OpenMode.ForRead);
                            if (layout == null) continue;
                            if (string.Equals(layout.LayoutName, "Model", StringComparison.OrdinalIgnoreCase)) continue;

                            var btr = (BlockTableRecord)tr.GetObject(layout.BlockTableRecordId, OpenMode.ForRead);

                            // Robust title block extents (union) in Paper/WCS
                            var tbUnion = GetTitleBlockUnionExtentsInPaper_Robust(btr, tr);

                            // Collect all viewports on this layout (skip special #1)
                            var vpIds = new List<ObjectId>();
                            foreach (ObjectId id in btr)
                            {
                                if (!id.IsValid) continue;
                                if (id.ObjectClass.DxfName != "VIEWPORT") continue;
                                var vp = tr.GetObject(id, OpenMode.ForRead) as Viewport;
                                if (vp == null || vp.Number == 1) continue;
                                vpIds.Add(id);
                            }
                            if (vpIds.Count == 0) continue;

                            // First pass: require overlap with TB (if we found a TB)
                            int added = 0;
                            bool haveTb = tbUnion.HasValue;

                            foreach (var vpId in vpIds)
                            {
                                var vp = (Viewport)tr.GetObject(vpId, OpenMode.ForRead);

                                bool include = true;
                                if (haveTb)
                                {
                                    var vpEx = GetViewportRectExtentsInPaper(vp);
                                    include = ExtentsOverlap2d(
                                        ExpandExtents2(tbUnion.Value, margin: 2.0), // generous margin
                                        ExpandExtents2(vpEx, margin: 0.0)
                                    );
                                }
                                if (!include) continue;

                                var ps2d = GetViewportBoundaryPointsInPaper(vp, tr);
                                if (ps2d == null || ps2d.Count < 3) continue;

                                var ms3d = PaperPolygonToModel_Correct(vp, ps2d);
                                if (ms3d != null && ms3d.Count >= 3)
                                {
                                    modelPolys.Add(ms3d);
                                    added++;
                                }
                            }

                            // Fallback: if TB overlap filter produced nothing, include ALL viewports on this layout
                            if (added == 0)
                            {
                                foreach (var vpId in vpIds)
                                {
                                    var vp = (Viewport)tr.GetObject(vpId, OpenMode.ForRead);
                                    var ps2d = GetViewportBoundaryPointsInPaper(vp, tr);
                                    if (ps2d == null || ps2d.Count < 3) continue;

                                    var ms3d = PaperPolygonToModel_Correct(vp, ps2d);
                                    if (ms3d != null && ms3d.Count >= 3)
                                        modelPolys.Add(ms3d);
                                }
                            }
                        }

                        tr.Commit();
                    }

                    if (modelPolys.Count == 0)
                    {
                        ed.WriteMessage("\nNo eligible viewport regions found on any paper space layout.");
                        return;
                    }

                    // ---- Select + Keep in Model space, erase everything else ----
                    SwitchToModelSpaceViewSafe(db, ed);

                    var keepIds = new HashSet<ObjectId>();
                    var originalUcs = ed.CurrentUserCoordinateSystem;
                    try
                    {
                        ed.CurrentUserCoordinateSystem = Matrix3d.Identity;

                        foreach (var poly in modelPolys)
                        {
                            var coll = new Point3dCollection(poly.ToArray());
                            var res = ed.SelectCrossingPolygon(coll);
                            if (res.Status == PromptStatus.OK)
                            {
                                foreach (var oid in res.Value.GetObjectIds())
                                    keepIds.Add(oid);
                            }
                        }
                    }
                    finally
                    {
                        ed.CurrentUserCoordinateSystem = originalUcs;
                    }

                    if (keepIds.Count == 0)
                    {
                        ed.WriteMessage("\nNothing found inside any viewport regions. Aborting without erasing.");
                        return;
                    }

                    var msId = SymbolUtilityServices.GetBlockModelSpaceId(db);
                    int erased = EraseEntitiesExcept(db, msId, keepIds);
                    ed.WriteMessage($"\nVP2PL: Kept {keepIds.Count} object(s) inside/crossing all viewport regions; erased {erased} others.");
                }
            }
            catch (System.Exception ex)
            {
                ed.WriteMessage($"\nVP2PL failed: {ex.Message}");
            }
        }

        // -------------------- Updated / New Helpers --------------------

        // Erase all entities in a space except those in keep-set. Returns count erased.
        private static int EraseEntitiesExcept(Database db, ObjectId spaceId, HashSet<ObjectId> keep)
        {
            int erased = 0;
            using (var tr = db.TransactionManager.StartTransaction())
            {
                var btr = (BlockTableRecord)tr.GetObject(spaceId, OpenMode.ForRead);
                var toErase = new List<Entity>();

                foreach (ObjectId id in btr)
                {
                    if (!id.IsValid) continue;
                    if (keep.Contains(id)) continue;

                    var ent = tr.GetObject(id, OpenMode.ForWrite, false) as Entity;
                    if (ent == null) continue;

                    try { toErase.Add(ent); } catch { }
                }

                foreach (var ent in toErase)
                {
                    try { if (!keep.Contains(ent.ObjectId) && !ent.IsErased) { ent.Erase(); erased++; } }
                    catch { /* keep going */ }
                }

                tr.Commit();
            }
            return erased;
        }

        private static void SwitchToModelSpaceViewSafe(Database db, Editor ed)
        {
            try
            {
                var modelId = SymbolUtilityServices.GetBlockModelSpaceId(db);
                if (db.CurrentSpaceId != modelId)
                {
                    try { ed.SwitchToModelSpace(); }
                    catch { try { Application.SetSystemVariable("TILEMODE", 1); } catch { } }
                }
            }
            catch { }
        }

        // More robust TB extents finder: named block refs OR largest closed polyline. Returns null if nothing plausible.
        private static Extents3d? GetTitleBlockUnionExtentsInPaper_Robust(BlockTableRecord layoutBtr, Transaction tr)
        {
            var named = new List<Extents3d>();
            var allBlocks = new List<(Extents3d ex, double area, string name)>();

            foreach (ObjectId id in layoutBtr)
            {
                if (!id.IsValid) continue;

                // Block refs
                if (id.ObjectClass.DxfName == "INSERT")
                {
                    var br = tr.GetObject(id, OpenMode.ForRead) as BlockReference;
                    if (br != null)
                    {
                        try
                        {
                            var def = (BlockTableRecord)tr.GetObject(br.BlockTableRecord, OpenMode.ForRead);
                            var name = def?.Name ?? string.Empty;
                            var ex = br.GeometricExtents;
                            double area = Math.Max(0, (ex.MaxPoint.X - ex.MinPoint.X)) * Math.Max(0, (ex.MaxPoint.Y - ex.MinPoint.Y));
                            if (area <= 1e-9) continue;

                            allBlocks.Add((ex, area, name));

                            var n = (name ?? string.Empty).ToUpperInvariant();
                            if (n.Contains("X-TB") || n.Contains(" TB") || n.StartsWith("TB") || n.Contains("TITLE") || n.Contains("BORDER"))
                                named.Add(ex);
                        }
                        catch { }
                    }
                }
            }

            // Prefer named matches (union all)
            if (named.Count > 0)
                return UnionExtents(named);

            // Fallback #1: largest block ref by extents area
            if (allBlocks.Count > 0)
            {
                var best = allBlocks.OrderByDescending(b => b.area).First().ex;
                return best;
            }

            // Fallback #2: largest closed polyline by extents area
            Extents3d? bestPlEx = null;
            double bestA = 0.0;
            foreach (ObjectId id in layoutBtr)
            {
                if (!id.IsValid) continue;
                var pl = tr.GetObject(id, OpenMode.ForRead) as Polyline;
                if (pl == null || !pl.Closed) continue;
                try
                {
                    var ex = pl.GeometricExtents;
                    double area = Math.Max(0, (ex.MaxPoint.X - ex.MinPoint.X)) * Math.Max(0, (ex.MaxPoint.Y - ex.MinPoint.Y));
                    if (area > bestA) { bestA = area; bestPlEx = ex; }
                }
                catch { }
            }
            return bestPlEx;
        }

        private static Extents3d UnionExtents(List<Extents3d> boxes)
        {
            var ex0 = boxes[0];
            double minX = ex0.MinPoint.X, minY = ex0.MinPoint.Y, minZ = ex0.MinPoint.Z;
            double maxX = ex0.MaxPoint.X, maxY = ex0.MaxPoint.Y, maxZ = ex0.MaxPoint.Z;

            for (int i = 1; i < boxes.Count; i++)
            {
                var ex = boxes[i];
                minX = Math.Min(minX, ex.MinPoint.X);
                minY = Math.Min(minY, ex.MinPoint.Y);
                minZ = Math.Min(minZ, ex.MinPoint.Z);
                maxX = Math.Max(maxX, ex.MaxPoint.X);
                maxY = Math.Max(maxY, ex.MaxPoint.Y);
                maxZ = Math.Max(maxZ, ex.MaxPoint.Z);
            }
            return new Extents3d(new Point3d(minX, minY, minZ), new Point3d(maxX, maxY, maxZ));
        }

        // Axis-aligned rect overlap in Paper (Z ignored)
        private static bool ExtentsOverlap2d(Extents3d a, Extents3d b)
        {
            return !(a.MaxPoint.X < b.MinPoint.X || a.MinPoint.X > b.MaxPoint.X ||
                     a.MaxPoint.Y < b.MinPoint.Y || a.MinPoint.Y > b.MaxPoint.Y);
        }

        private static Extents3d ExpandExtents2(Extents3d ex, double margin)
        {
            return new Extents3d(
                new Point3d(ex.MinPoint.X - margin, ex.MinPoint.Y - margin, ex.MinPoint.Z),
                new Point3d(ex.MaxPoint.X + margin, ex.MaxPoint.Y + margin, ex.MaxPoint.Z)
            );
        }

        private static Extents3d GetViewportRectExtentsInPaper(Viewport vp)
        {
            double w = vp.Width, h = vp.Height;
            var c = vp.CenterPoint;
            return new Extents3d(
                new Point3d(c.X - w / 2.0, c.Y - h / 2.0, 0.0),
                new Point3d(c.X + w / 2.0, c.Y + h / 2.0, 0.0)
            );
        }

        // PAPER-SPACE boundary (rect or clipped)
        private static List<Point2d> GetViewportBoundaryPointsInPaper(Viewport vp, Transaction tr)
        {
            if (vp.NonRectClipOn && !vp.NonRectClipEntityId.IsNull)
            {
                var clipEnt = tr.GetObject(vp.NonRectClipEntityId, OpenMode.ForRead) as Entity;
                if (clipEnt != null)
                {
                    var pl = PolylineFromClipEntity(clipEnt, tr);
                    if (pl != null)
                        return SamplePolyline2d(pl, arcSegsPerQuarter: 12);
                }
            }

            double w = vp.Width, h = vp.Height;
            if (w <= 0 || h <= 0) return null;

            var c = vp.CenterPoint;
            double minX = c.X - w / 2.0, maxX = c.X + w / 2.0;
            double minY = c.Y - h / 2.0, maxY = c.Y + h / 2.0;

            return new List<Point2d>
            {
                new Point2d(minX, minY),
                new Point2d(maxX, minY),
                new Point2d(maxX, maxY),
                new Point2d(minX, maxY)
            };
        }

        // Correct PS→MS mapping (accounts for ViewCenter, ViewHeight/Height, TwistAngle)
        private static List<Point3d> PaperPolygonToModel_Correct(Viewport vp, List<Point2d> ps)
        {
            var ms = new List<Point3d>(ps.Count);

            var z = vp.ViewDirection.GetNormal();
            var x0 = (Math.Abs(z.DotProduct(Vector3d.ZAxis)) > 0.999999)
                        ? Vector3d.XAxis
                        : z.GetPerpendicularVector().GetNormal();
            var y0 = z.CrossProduct(x0).GetNormal();

            double twist = vp.TwistAngle;
            var x = x0 * Math.Cos(twist) + y0 * Math.Sin(twist);
            var y = (-x0) * Math.Sin(twist) + y0 * Math.Cos(twist);

            double muPerPu = vp.ViewHeight / vp.Height;
            var target = vp.ViewTarget;
            var vc = vp.ViewCenter; // DCS coords at viewport center

            foreach (var p in ps)
            {
                double dxPS = p.X - vp.CenterPoint.X;
                double dyPS = p.Y - vp.CenterPoint.Y;

                double u = (vc.X + dxPS * muPerPu);
                double v = (vc.Y + dyPS * muPerPu);

                var pt = target + x.MultiplyBy(u) + y.MultiplyBy(v);
                ms.Add(pt);
            }
            return ms;
        }

        // ---- clip entity → polyline helpers (no debug drawing) ----

        private static Polyline PolylineFromClipEntity(Entity ent, Transaction tr)
        {
            switch (ent)
            {
                case Polyline p2d: return ClonePolyline(p2d);
                case Polyline2d p2: return FromPolyline2d(p2, tr);
                case Circle c: return FromCircle(c);
                case Ellipse e: return FromEllipseApprox(e, 64);
                case Spline s: return FromSplineApprox(s, 128);
                default: return FromExplodeLinesArcs(ent);
            }
        }

        private static Polyline ClonePolyline(Polyline src)
        {
            var dst = new Polyline(src.NumberOfVertices);
            for (int i = 0; i < src.NumberOfVertices; i++)
            {
                var pt = src.GetPoint2dAt(i);
                double bulge = src.GetBulgeAt(i);
                dst.AddVertexAt(i, pt, bulge, 0, 0);
            }
            dst.Closed = src.Closed;
            return dst;
        }

        private static Polyline FromPolyline2d(Polyline2d p2, Transaction tr)
        {
            var verts = new List<(Point2d pt, double bulge)>();
            foreach (ObjectId vId in p2)
            {
                var v = (Vertex2d)tr.GetObject(vId, OpenMode.ForRead);
                verts.Add((new Point2d(v.Position.X, v.Position.Y), v.Bulge));
            }
            if (verts.Count < 2) return null;

            var pl = new Polyline(verts.Count);
            for (int i = 0; i < verts.Count; i++)
                pl.AddVertexAt(i, verts[i].pt, verts[i].bulge, 0, 0);

            pl.Closed = p2.Closed || verts[0].pt.GetDistanceTo(verts[^1].pt) <= 1e-9;
            return pl;
        }

        private static Polyline FromCircle(Circle c)
        {
            var center = c.Center;
            double r = c.Radius;
            if (r <= 0) return null;

            var p0 = new Point2d(center.X + r, center.Y);
            var p1 = new Point2d(center.X, center.Y + r);
            var p2 = new Point2d(center.X - r, center.Y);
            var p3 = new Point2d(center.X, center.Y - r);

            double bulge90 = Math.Tan(Math.PI / 8.0);

            var pl = new Polyline(4);
            pl.AddVertexAt(0, p0, bulge90, 0, 0);
            pl.AddVertexAt(1, p1, bulge90, 0, 0);
            pl.AddVertexAt(2, p2, bulge90, 0, 0);
            pl.AddVertexAt(3, p3, bulge90, 0, 0);
            pl.Closed = true;
            return pl;
        }

        private static Polyline FromEllipseApprox(Ellipse e, int segments)
        {
            if (segments < 8) segments = 8;
            var curve = (Curve)e;
            double t0 = curve.StartParam, t1 = curve.EndParam;

            var pl = new Polyline(segments);
            for (int i = 0; i < segments; i++)
            {
                double t = t0 + (t1 - t0) * (double)i / (double)segments;
                var p = curve.GetPointAtParameter(t);
                pl.AddVertexAt(i, new Point2d(p.X, p.Y), 0, 0, 0);
            }
            var pend = curve.GetPointAtParameter(t1);
            pl.AddVertexAt(segments, new Point2d(pend.X, pend.Y), 0, 0, 0);
            pl.Closed = true;
            return pl;
        }

        private static Polyline FromSplineApprox(Spline s, int segments)
        {
            if (segments < 8) segments = 8;
            var curve = (Curve)s;
            double t0 = curve.StartParam, t1 = curve.EndParam;

            var pl = new Polyline(segments + 1);
            for (int i = 0; i <= segments; i++)
            {
                double t = t0 + (t1 - t0) * (double)i / (double)segments;
                var p = curve.GetPointAtParameter(t);
                pl.AddVertexAt(i, new Point2d(p.X, p.Y), 0, 0, 0);
            }
            pl.Closed = s.Closed;
            return pl;
        }

        private static double BulgeFromArc(Arc arc)
        {
            double r = arc.Radius;
            if (r <= 0) return 0.0;
            double theta = arc.Length / r;

            Vector3d v1 = arc.StartPoint - arc.Center;
            Vector3d v2 = arc.EndPoint - arc.Center;
            double sign = Math.Sign(arc.Normal.DotProduct(v1.CrossProduct(v2)));

            double bulge = Math.Tan(theta / 4.0);
            if (sign < 0) bulge = -bulge;
            return bulge;
        }

        private static Polyline FromExplodeLinesArcs(Entity e)
        {
            try
            {
                using (var res = new DBObjectCollection())
                {
                    e.Explode(res);
                    var segments = new List<(Point3d s, Point3d e, double bulge)>();
                    foreach (DBObject dbo in res)
                    {
                        if (dbo is Line ln) segments.Add((ln.StartPoint, ln.EndPoint, 0.0));
                        else if (dbo is Arc arc) segments.Add((arc.StartPoint, arc.EndPoint, BulgeFromArc(arc)));
                        dbo.Dispose();
                    }
                    if (segments.Count == 0) return null;

                    var chain = StitchSegments(segments);
                    if (chain == null || chain.Count < 2) return null;

                    var pl = new Polyline(chain.Count);
                    for (int i = 0; i < chain.Count; i++)
                    {
                        var node = chain[i];
                        pl.AddVertexAt(i, new Point2d(node.s.X, node.s.Y), node.bulge, 0, 0);
                    }
                    if (chain[0].s.DistanceTo(chain[^1].e) < 1e-6) pl.Closed = true;
                    return pl;
                }
            }
            catch { return null; }
        }

        private static List<(Point3d s, Point3d e, double bulge)> StitchSegments(List<(Point3d s, Point3d e, double bulge)> segs)
        {
            if (segs.Count == 0) return null;
            var chain = new List<(Point3d s, Point3d e, double bulge)> { segs[0] };
            segs.RemoveAt(0);

            const double tol = 1e-6;
            while (segs.Count > 0)
            {
                var last = chain[^1];
                int found = -1;
                bool reverse = false;

                for (int i = 0; i < segs.Count; i++)
                {
                    if (last.e.DistanceTo(segs[i].s) < tol) { found = i; reverse = false; break; }
                    if (last.e.DistanceTo(segs[i].e) < tol) { found = i; reverse = true; break; }
                }
                if (found < 0) break;

                var seg = segs[found];
                segs.RemoveAt(found);
                chain.Add(reverse ? (seg.e, seg.s, -seg.bulge) : seg);
            }
            return chain;
        }

        private static List<Point2d> SamplePolyline2d(Polyline pl, int arcSegsPerQuarter = 12)
        {
            var pts = new List<Point2d>();
            int n = pl.NumberOfVertices;
            if (n == 0) return pts;

            for (int i = 0; i < n; i++)
            {
                var a = pl.GetPoint2dAt(i);
                var b = pl.GetPoint2dAt((i + 1) % n);
                double bulge = pl.GetBulgeAt(i);

                pts.Add(a);

                if (Math.Abs(bulge) > 1e-12)
                {
                    foreach (var q in SampleBulge(a, b, bulge, Math.Max(2, (int)Math.Ceiling(Math.Abs(4 * Math.Atan(bulge)) / (Math.PI / (2.0 * arcSegsPerQuarter))))))
                        pts.Add(q);
                }
            }
            return pts;
        }

        private static IEnumerable<Point2d> SampleBulge(Point2d a, Point2d b, double bulge, int segs)
        {
            Vector2d v = b - a;
            double L = v.Length;
            if (L < 1e-12) yield break;

            double theta = 4.0 * Math.Atan(bulge);
            double half = theta / 2.0;
            double d = (L / 2.0) / Math.Tan(half);

            Vector2d t = v / L;
            Vector2d n = new Vector2d(-t.Y, t.X);
            if (bulge < 0) n = -n;

            var mid = new Point2d((a.X + b.X) * 0.5, (a.Y + b.Y) * 0.5);
            var cen = new Point2d(mid.X + n.X * d, mid.Y + n.Y * d);

            double ang0 = Math.Atan2(a.Y - cen.Y, a.X - cen.X);
            double R = (new Vector2d(a.X - cen.X, a.Y - cen.Y)).Length;

            for (int i = 1; i < segs; i++)
            {
                double ang = ang0 + (theta * i) / segs;
                yield return new Point2d(cen.X + Math.Cos(ang) * R, cen.Y + Math.Sin(ang) * R);
            }
        }
    }
}
```
===== END ViewportToPolyline.cs =====

